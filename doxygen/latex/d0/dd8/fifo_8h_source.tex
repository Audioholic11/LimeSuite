\subsection{fifo.\+h}
\label{fifo_8h_source}\index{/home/erik/prefix/default/src/limesuite-\/dev/src/protocols/fifo.\+h@{/home/erik/prefix/default/src/limesuite-\/dev/src/protocols/fifo.\+h}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#ifndef LMS\_FIFO\_BUFFER\_H}
00002 \textcolor{preprocessor}{#define LMS\_FIFO\_BUFFER\_H}
00003 
00004 \textcolor{preprocessor}{#include <mutex>}
00005 \textcolor{preprocessor}{#include <condition\_variable>}
00006 \textcolor{preprocessor}{#include <atomic>}
00007 \textcolor{preprocessor}{#include <vector>}
00008 \textcolor{preprocessor}{#include <thread>}
00009 \textcolor{preprocessor}{#include <queue>}
00010 \textcolor{preprocessor}{#include <condition\_variable>}
00011 \textcolor{preprocessor}{#include "dataTypes.h"}
00012 \textcolor{preprocessor}{#include <cmath>}
00013 \textcolor{preprocessor}{#include <assert.h>}
00014 
00015 \textcolor{keyword}{namespace }lime\{
00016 
00017 \textcolor{keyword}{class }RingFIFO
00018 \{
00019 \textcolor{keyword}{public}:
00020 
00021     \textcolor{keyword}{struct }BufferInfo
00022     \{
00023         uint32\_t size;
00024         uint32\_t itemsFilled;
00025     \};
00026 
00027     \textcolor{keyword}{enum} StreamFlags
00028     \{
00029         SYNC_TIMESTAMP = 1,
00030         END_BURST = 2,
00031         OVERWRITE_OLD = 4,
00032     \};
00033 
00035     BufferInfo GetInfo()
00036     \{
00037         std::unique\_lock<std::mutex> lck(lock);
00038         BufferInfo stats;
00039         stats.size = mBufferSize*mBuffer->maxSamplesInPacket;
00040         stats.itemsFilled = mElementsFilled*mBuffer->maxSamplesInPacket;
00041         \textcolor{keywordflow}{return} stats;
00042     \}
00043 
00045     RingFIFO(\textcolor{keyword}{const} uint32\_t bufLength) : mBufferSize(1+(bufLength-1)/mBuffer->maxSamplesInPacket)
00046     \{
00047         mBuffer = \textcolor{keyword}{new} SamplesPacket[mBufferSize];
00048         Clear();
00049     \}
00050 
00051     ~RingFIFO()
00052     \{
00053         \textcolor{keyword}{delete} []mBuffer;
00054     \};
00055 
00064     uint32\_t push_samples(\textcolor{keyword}{const} complex16_t *buffer, \textcolor{keyword}{const} uint32\_t samplesCount, \textcolor{keyword}{const} uint8\_t 
      channelsCount, uint64\_t timestamp, \textcolor{keyword}{const} uint32\_t timeout_ms, \textcolor{keyword}{const} uint32\_t flags = 0, uint64\_t lastchirp\_timestamp = 
      0, uint64\_t chirptime  = 0)
00065     \{
00066         assert(buffer != \textcolor{keyword}{nullptr});
00067         uint32\_t samplesTaken = 0;
00068         std::unique\_lock<std::mutex> lck(lock);
00069         \textcolor{keyword}{auto} t1 = std::chrono::high\_resolution\_clock::now();
00070         \textcolor{keywordflow}{while} (samplesTaken < samplesCount)
00071         \{
00072             \textcolor{keywordflow}{if} (mElementsFilled >= mBufferSize) \textcolor{comment}{//buffer might be full, wait for free slots}
00073             \{
00074                 \textcolor{keyword}{auto} t2 = std::chrono::high\_resolution\_clock::now();
00075                 \textcolor{keywordflow}{if}(t2-t1 >= std::chrono::milliseconds(timeout\_ms))
00076                     \textcolor{keywordflow}{return} samplesTaken;
00077                 \textcolor{keywordflow}{if}(flags & OVERWRITE_OLD)
00078                 \{
00079                     \textcolor{keywordtype}{int} dropElements = 1+(samplesCount-samplesTaken)/
      SamplesPacket::maxSamplesInPacket;
00080                     mHead = (mHead + dropElements) & (mBufferSize - 1);\textcolor{comment}{//advance to next one}
00081                     mElementsFilled -= dropElements;
00082                 \}
00083                 \textcolor{keywordflow}{else}  \textcolor{comment}{//there is no space, wait on CV to give pop\_samples the thread context}
00084                 \{
00085                     hasItems.wait\_for(lck, std::chrono::milliseconds(timeout\_ms));
00086                 \}
00087             \}
00088             \textcolor{keywordflow}{else}
00089             \{
00090                 mBuffer[mTail].timestamp = timestamp + samplesTaken;
00091                 mBuffer[mTail].lastchirp_timestamp = lastchirp\_timestamp;
00092                 mBuffer[mTail].chirptime = chirptime;
00093                 \textcolor{keywordtype}{int} cnt = samplesCount-samplesTaken;
00094                 \textcolor{keywordflow}{if} (cnt > SamplesPacket::maxSamplesInPacket)
00095                 \{
00096                     cnt = SamplesPacket::maxSamplesInPacket;
00097                     mBuffer[mTail].flags = flags & SYNC_TIMESTAMP;
00098                 \}
00099                 \textcolor{keywordflow}{else}
00100                     mBuffer[mTail].flags = flags;
00101                 memcpy(mBuffer[mTail].samples,&buffer[samplesTaken],cnt*\textcolor{keyword}{sizeof}(
      complex16_t));
00102                 samplesTaken+=cnt;
00103                 mBuffer[mTail].last = cnt;
00104                 mBuffer[mTail++].first = 0;
00105                 mTail  &= (mBufferSize - 1);\textcolor{comment}{//advance to next one}
00106                 ++mElementsFilled;
00107             \}
00108         \}
00109         lck.unlock();
00110         hasItems.notify\_one();
00111         \textcolor{keywordflow}{return} samplesTaken;
00112     \}
00113 
00123     uint32\_t pop_samples(complex16_t* buffer, \textcolor{keyword}{const} uint32\_t samplesCount, \textcolor{keyword}{const} uint8\_t channelsCount, 
      uint64\_t *timestamp, \textcolor{keyword}{const} uint32\_t timeout_ms, uint32\_t *flags = \textcolor{keyword}{nullptr},uint64\_t *lastchirp\_timestamp = 0, 
      uint64\_t *chirptime = 0)
00124     \{
00125         assert(buffer != \textcolor{keyword}{nullptr});
00126         uint32\_t samplesFilled = 0;
00127         \textcolor{keywordflow}{if} (flags != \textcolor{keyword}{nullptr}) *flags = 0;
00128         std::unique\_lock<std::mutex> lck(lock);
00129         \textcolor{keywordflow}{while} (samplesFilled < samplesCount)
00130         \{
00131             \textcolor{keywordflow}{while} (mElementsFilled == 0) \textcolor{comment}{//buffer might be empty, wait for packets}
00132             \{
00133                 \textcolor{keywordflow}{if} (timeout\_ms == 0)
00134                     \textcolor{keywordflow}{return} samplesFilled;
00135                 \textcolor{keywordflow}{if} (hasItems.wait\_for(lck, std::chrono::milliseconds(timeout\_ms)) == 
      std::cv\_status::timeout)
00136                     \textcolor{keywordflow}{return} samplesFilled;
00137             \}
00138             \textcolor{keywordflow}{if}(samplesFilled == 0 && timestamp != \textcolor{keyword}{nullptr})
00139                 *timestamp = mBuffer[mHead].timestamp + mBuffer[mHead].first;
00140 
00141             \textcolor{keywordflow}{if}(samplesFilled == 0 && lastchirp\_timestamp != \textcolor{keyword}{nullptr})
00142                     *lastchirp\_timestamp = mBuffer[mHead].lastchirp_timestamp + 
      mBuffer[mHead].first;
00143 
00144             \textcolor{keywordflow}{if}(samplesFilled == 0 && chirptime != \textcolor{keyword}{nullptr})
00145                     *chirptime = mBuffer[mHead].chirptime;
00146 
00147 
00148             \textcolor{keywordflow}{while}(mElementsFilled > 0 && samplesFilled < samplesCount)
00149             \{
00150                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} hasEOB = mBuffer[mHead].flags & END_BURST;
00151                 \textcolor{keywordflow}{if} (flags != \textcolor{keyword}{nullptr}) *flags |= mBuffer[mHead].flags;
00152                 \textcolor{keyword}{const} \textcolor{keywordtype}{int} first = mBuffer[mHead].first;
00153 
00154                 \textcolor{keywordtype}{int} cnt = samplesCount - samplesFilled;
00155                 \textcolor{keyword}{const} \textcolor{keywordtype}{int} cntbuf = mBuffer[mHead].last - first;
00156                 cnt = cnt > cntbuf ? cntbuf : cnt;
00157 
00158                 memcpy(&buffer[samplesFilled],&mBuffer[mHead].samples[first],cnt*\textcolor{keyword}{sizeof}(
      complex16_t));
00159                 samplesFilled += cnt;
00160 
00161                 \textcolor{keywordflow}{if} (cntbuf == cnt) \textcolor{comment}{//packet depleated}
00162                 \{
00163                     mHead = (mHead + 1) & (mBufferSize - 1);\textcolor{comment}{//advance to next one}
00164                     --mElementsFilled;
00165                 \}
00166                 \textcolor{keywordflow}{else}
00167                     mBuffer[mHead].first += cnt;
00168 
00169                 \textcolor{comment}{//leave the loop early when end of burst is encountered}
00170                 \textcolor{comment}{//so that the calling loop can flush out the buffer}
00171                 \textcolor{keywordflow}{if} (hasEOB) \textcolor{keywordflow}{goto} done;
00172             \}
00173         \}
00174         done:
00175         lck.unlock();
00176         hasItems.notify\_one();
00177         \textcolor{keywordflow}{return} samplesFilled;
00178     \}
00179 
00180     \textcolor{keywordtype}{void} Clear()
00181     \{
00182         std::unique\_lock<std::mutex> lck(lock);
00183         mHead = 0;
00184         mTail = 0;
00185         mElementsFilled = 0;
00186     \}
00187 
00188 \textcolor{keyword}{protected}:
00189     \textcolor{keyword}{const} uint32\_t mBufferSize;
00190     SamplesPacket* mBuffer;
00191     uint32\_t mHead;
00192     uint32\_t mTail;
00193     uint32\_t mElementsFilled;
00194     std::mutex lock;
00195     std::condition\_variable hasItems;
00196 \};
00197 
00198 \textcolor{comment}{//
      https://www.justsoftwaresolutions.co.uk/threading/implementing-a-thread-safe-queue-using-condition-variables.html}
00199 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00200 \textcolor{keyword}{class }ConcurrentQueue
00201 \{
00202 \textcolor{keyword}{private}:
00203     std::queue<T> mQueue;
00204     std::mutex mMutex;
00205     std::condition\_variable mCond;
00206 \textcolor{keyword}{public}:
00207     \textcolor{keywordtype}{void} push(T \textcolor{keyword}{const}& data)
00208     \{
00209         std::unique\_lock<std::mutex> lock(mMutex);
00210         mQueue.push(data);
00211         lock.unlock();
00212         mCond.notify\_one();
00213     \}
00214 
00215     \textcolor{keywordtype}{bool} empty()\textcolor{keyword}{ const}
00216 \textcolor{keyword}{    }\{
00217         std::unique\_lock<std::mutex> lock(mMutex);
00218         \textcolor{keywordflow}{return} mQueue.empty();
00219     \}
00220 
00221     \textcolor{keywordtype}{bool} try_pop(T& popped\_value)
00222     \{
00223         std::unique\_lock<std::mutex> lock(mMutex);
00224         \textcolor{keywordflow}{if}(mQueue.empty())
00225         \{
00226             \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00227         \}
00228         popped\_value=mQueue.front();
00229         mQueue.pop();
00230         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00231     \}
00232 
00233     \textcolor{keywordtype}{void} wait_and_pop(T& popped\_value)
00234     \{
00235         std::unique\_lock<std::mutex> lock(mMutex);
00236         \textcolor{keywordflow}{while}(mQueue.empty())
00237         \{
00238             mCond.wait(lock);
00239         \}
00240         popped\_value=mQueue.front();
00241         mQueue.pop();
00242     \}
00243 
00244     \textcolor{keywordtype}{bool} wait_and_pop(T& popped\_value, \textcolor{keyword}{const} \textcolor{keywordtype}{int} timeout_ms)
00245     \{
00246         std::unique\_lock<std::mutex> lock(mMutex);
00247         \textcolor{keywordflow}{while}(mQueue.empty())
00248         \{
00249             \textcolor{keywordflow}{if} (mCond.wait\_for(lock, std::chrono::milliseconds(timeout\_ms)) == std::cv\_status::timeout)
00250                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00251         \}
00252         popped\_value=mQueue.front();
00253         mQueue.pop();
00254         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00255     \}
00256 \};
00257 
00258 \}
00259 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
