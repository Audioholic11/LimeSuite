\subsection{lms7002m\+\_\+agc.\+c}
\label{lms7002m__agc_8c_source}\index{/home/erik/prefix/default/src/limesuite-\/dev/mcu\+\_\+program/common\+\_\+src/lms7002m\+\_\+agc.\+c@{/home/erik/prefix/default/src/limesuite-\/dev/mcu\+\_\+program/common\+\_\+src/lms7002m\+\_\+agc.\+c}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#include "lms7002m_controls.h"}
00002 \textcolor{preprocessor}{#include "spi.h"}
00003 \textcolor{preprocessor}{#include "LMS7002M_parameters_compact.h"}
00004 \textcolor{preprocessor}{#include "typedefs.h"}
00005 \textcolor{preprocessor}{#include "mcu_defines.h"}
00006 \textcolor{preprocessor}{#include "lms7002m_calibrations.h"}
00007 
00008 
00009 \textcolor{preprocessor}{#include <math.h>}
00010 
00011 \textcolor{preprocessor}{#ifdef \_\_cplusplus}
00012 \textcolor{keywordtype}{bool} hasStopped = \textcolor{keyword}{false};
00013 \textcolor{keywordtype}{bool} stopProcedure = \textcolor{keyword}{false};
00014 \textcolor{preprocessor}{#else}
00015 \textcolor{keyword}{extern} \textcolor{keywordtype}{bool} hasStopped;
00016 \textcolor{keyword}{extern} \textcolor{keywordtype}{bool} stopProcedure;
00017 \textcolor{preprocessor}{#endif}
00018 
00019 \textcolor{keyword}{static} uint16\_t ROM stateAddresses[] = \{0x0081, 0x010F, 0x0126, 0x040A, 0x040C\};
00020 \textcolor{comment}{//double space to store both channels}
00021 \textcolor{keyword}{static} uint16\_t xdata stateStorage[2*\textcolor{keyword}{sizeof}(stateAddresses)/\textcolor{keyword}{sizeof}(uint16\_t)];
00022 
00023 \textcolor{keyword}{static} \textcolor{keywordtype}{void} StoreState(\textcolor{keywordtype}{bool} write)
00024 \{
00025     uint16\_t x0020 = SPI_read(0x0020);
00026     uint8\_t storageIndex = 0;
00027     uint8\_t ch;
00028     \textcolor{keywordflow}{for}(ch = 2; ch>0; --ch)
00029     \{
00030         uint8\_t i = 0;
00031         SPI_write(0x0020, (x0020 & 0xFFFC) | i);
00032         \textcolor{keywordflow}{for}(; i < \textcolor{keyword}{sizeof}(stateAddresses)/\textcolor{keyword}{sizeof}(uint16\_t); ++i)
00033         \{
00034             \textcolor{keywordflow}{if}(write)
00035                 SPI_write(stateAddresses[i], stateStorage[storageIndex]);
00036             \textcolor{keywordflow}{else}
00037                 stateStorage[storageIndex] = SPI_read(stateAddresses[i]);
00038             ++storageIndex;
00039         \}
00040     \}
00041     SPI_write(0x0020, x0020);
00042 \}
00043 
00044 \textcolor{preprocessor}{#define TABLE\_ENTRY(gain\_setting, gainLNA, gainPGA) (gainPGA << 4 | gainLNA)}
00045 \textcolor{preprocessor}{#define GET\_PGA\_GAIN(value) ((value >> 4) & 0x1F)}
00046 \textcolor{preprocessor}{#define GET\_LNA\_GAIN(value) ((value) & 0xF)}
00047 \textcolor{keyword}{static} ROM \textcolor{keyword}{const} uint16\_t AGC_gain_table[] = \{
00048 TABLE_ENTRY(-12,1,0),
00049 TABLE_ENTRY(-11,1,1),
00050 TABLE_ENTRY(-10,1,2),
00051 TABLE_ENTRY(-9,2,0),
00052 TABLE_ENTRY(-8,2,1),
00053 TABLE_ENTRY(-7,2,2),
00054 TABLE_ENTRY(-6,2,3),
00055 TABLE_ENTRY(-5,3,1),
00056 TABLE_ENTRY(-4,3,2),
00057 TABLE_ENTRY(-3,3,3),
00058 TABLE_ENTRY(-2,3,4),
00059 TABLE_ENTRY(-1,4,2),
00060 TABLE_ENTRY(0,4,3),
00061 TABLE_ENTRY(1,4,4),
00062 TABLE_ENTRY(2,4,5),
00063 TABLE_ENTRY(3,5,3),
00064 TABLE_ENTRY(4,5,4),
00065 TABLE_ENTRY(5,5,5),
00066 TABLE_ENTRY(6,5,6),
00067 TABLE_ENTRY(7,6,4),
00068 TABLE_ENTRY(8,6,5),
00069 TABLE_ENTRY(9,6,6),
00070 TABLE_ENTRY(10,6,7),
00071 TABLE_ENTRY(11,7,5),
00072 TABLE_ENTRY(12,7,6),
00073 TABLE_ENTRY(13,7,7),
00074 TABLE_ENTRY(14,7,8),
00075 TABLE_ENTRY(15,8,6),
00076 TABLE_ENTRY(16,8,7),
00077 TABLE_ENTRY(17,8,8),
00078 TABLE_ENTRY(18,8,9),
00079 TABLE_ENTRY(19,9,7),
00080 TABLE_ENTRY(20,9,8),
00081 TABLE_ENTRY(21,9,9),
00082 TABLE_ENTRY(22,9,10),
00083 TABLE_ENTRY(23,10,10),
00084 TABLE_ENTRY(24,10,11),
00085 TABLE_ENTRY(25,10,12),
00086 TABLE_ENTRY(26,10,13),
00087 TABLE_ENTRY(27,11,13),
00088 TABLE_ENTRY(28,11,14),
00089 TABLE_ENTRY(29,11,15),
00090 TABLE_ENTRY(30,11,16),
00091 TABLE_ENTRY(31,11,17),
00092 TABLE_ENTRY(32,11,18),
00093 TABLE_ENTRY(33,11,19),
00094 TABLE_ENTRY(34,11,20),
00095 TABLE_ENTRY(35,11,21),
00096 TABLE_ENTRY(36,11,22),
00097 TABLE_ENTRY(37,11,23),
00098 TABLE_ENTRY(38,11,24),
00099 TABLE_ENTRY(39,11,25),
00100 TABLE_ENTRY(40,11,26),
00101 TABLE_ENTRY(41,11,27),
00102 TABLE_ENTRY(42,11,28),
00103 TABLE_ENTRY(43,11,29),
00104 TABLE_ENTRY(44,11,30),
00105 TABLE_ENTRY(45,11,31),
00106 TABLE_ENTRY(46,12,31),
00107 TABLE_ENTRY(47,13,31),
00108 TABLE_ENTRY(48,14,31),
00109 TABLE_ENTRY(49,15,31)
00110 \};
00111 
00112 uint8\_t RunAGC(uint32\_t wantedRSSI)
00113 \{
00114     xdata uint32\_t lastRSSI[2];
00115     uint16\_t x0400[2];
00116     uint8\_t status;
00117     uint8\_t gainLNA[2];
00118     uint8\_t gainPGA[2];
00119     uint8\_t ch;
00120     uint16\_t x0020 = SPI_read(0x0020);
00121     gainLNA[1] = gainLNA[0] = 11;
00122     gainPGA[1] = gainPGA[0] = 31;
00123     hasStopped = \textcolor{keyword}{false};
00124     StoreState(\textcolor{keyword}{false});
00125     \textcolor{comment}{//Setup}
00126     \textcolor{keywordflow}{if}(Get_SPI_Reg_bits(TRX_GAIN_SRC) == \textcolor{keyword}{false})
00127     \{
00128         \textcolor{keywordflow}{for}(ch=0; ch<2; ++ch)
00129         \{
00130             SPI_write(0x0020, (x0020 & 0xFFFC) | (ch+1));
00131             Modify_SPI_Reg_bits(CG_IAMP_TBB_R3, Get_SPI_Reg_bits(CG_IAMP_TBB));
00132             Modify_SPI_Reg_bits(LOSS_LIN_TXPAD_TRF_R3, Get_SPI_Reg_bits(
      LOSS_LIN_TXPAD_TRF));
00133             Modify_SPI_Reg_bits(LOSS_MAIN_TXPAD_TRF_R3, Get_SPI_Reg_bits(
      LOSS_MAIN_TXPAD_TRF));
00134         \}
00135     \}
00136     Modify_SPI_Reg_bits(TRX_GAIN_SRC, 1);
00137     \textcolor{keywordflow}{for}(ch=0; ch<2; ++ch)
00138     \{
00139         SPI_write(0x0020, (x0020 & 0xFFFC) | (ch+1));
00140         Modify_SPI_Reg_bits(ICT_TIAMAIN_RFE, 31);
00141         Modify_SPI_Reg_bits(ICT_TIAOUT_RFE, 4);
00142         \textcolor{comment}{//C\_CTL\_PGA\_RBB 0, TIA 2}
00143         SPI_write(0x0126, (gainPGA[ch] << 6) | (gainLNA[ch] << 2) | 2);
00144 
00145         status = CalibrateRx(\textcolor{keyword}{false}, \textcolor{keyword}{false});
00146         \textcolor{comment}{//if(status != MCU\_NO\_ERROR)}
00147             \textcolor{comment}{//goto AGC\_END;}
00148         \textcolor{comment}{//Modify\_SPI\_Reg\_bits(AGC\_MODE\_RXTSP, 1);}
00149         \textcolor{comment}{//Modify\_SPI\_Reg\_bits(AGC\_AVG\_RXTSP, 0);}
00150         SPI_write(0x040A, 0x1000);
00151         Modify_SPI_Reg_bits(AGC_BYP_RXTSP, 0);
00152 
00153         \textcolor{keywordflow}{if}(Get_SPI_Reg_bits(CMIX_BYP_RXTSP) == 0)
00154         \{
00155             Modify_SPI_Reg_bits(CMIX_GAIN_RXTSP, 1);
00156             Modify_SPI_Reg_bits(CMIX_GAIN_RXTSP_R3, 0);
00157         \}
00158         x0400[ch] = SPI_read(0x0400) & ~0xF000; \textcolor{comment}{//CAPTURE 0, CAPSEL 0}
00159     \}
00160     UpdateRSSIDelay();
00161 
00162     \textcolor{keywordflow}{while}(!stopProcedure)
00163     \{
00164         \textcolor{comment}{//Need to wait only}
00165         \textcolor{keywordflow}{for}(ch=0; ch<2; ++ch)
00166         \{
00167             \textcolor{keywordtype}{float} dBdiff;
00168             uint8\_t LNA\_gain\_available;
00169             uint32\_t rssi;
00170             \textcolor{keywordtype}{bool} needUpdate = \textcolor{keyword}{false};
00171             SPI_write(0x0020, (x0020 & 0xFFFC) | (ch+1));
00172             \textcolor{comment}{//CAPTURE RSSI}
00173             SPI_write(0x0400, x0400[ch]);
00174             SPI_write(0x0400, x0400[ch] | 0x8000);
00175             rssi = SPI_read(0x040F);
00176             rssi = (rssi << 2 | (SPI_read(0x040E) & 0x3));
00177 
00178             \textcolor{keywordflow}{if}(rssi == lastRSSI[ch] || rssi == 0)
00179                 \textcolor{keywordflow}{continue};
00180             lastRSSI[ch] = rssi;
00181 
00182             \textcolor{keywordflow}{if}(gainLNA[ch] <= 9)
00183                 LNA\_gain\_available = 3*(11-gainLNA[ch]); \textcolor{comment}{//G\_LNA=0 not allowed}
00184             \textcolor{keywordflow}{else}
00185                 LNA\_gain\_available = 15-gainLNA[ch];
00186 
00187             dBdiff = 20*log10((\textcolor{keywordtype}{float})wantedRSSI/rssi);
00188             \textcolor{keywordflow}{if} (dBdiff < 0 && rssi > 0x14000)
00189             \{
00190                 gainPGA[ch] = clamp(gainPGA[ch] - 12, 0, 31);
00191                 gainLNA[ch] = clamp(gainLNA[ch] -  3, 0, 15);
00192                 needUpdate = \textcolor{keyword}{true};
00193             \}
00194             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dBdiff < 0 || (dBdiff > 0 && LNA\_gain\_available+31-gainPGA[ch] > 0))
00195             \{
00196                 int8\_t total\_gain\_current = 30-LNA\_gain\_available + gainPGA[ch];
00197                 \textcolor{keyword}{const} uint16\_t gains = AGC_gain_table[clamp(total\_gain\_current+dBdiff, 0, 61)];
00198                 uint8\_t newLNA = GET_LNA_GAIN(gains);
00199                 uint8\_t newPGA = GET_PGA_GAIN(gains);
00200                 \textcolor{keywordflow}{if}(newPGA != gainPGA[ch] || newLNA != gainLNA[ch])
00201                 \{
00202                     gainLNA[ch] = GET_LNA_GAIN(gains);
00203                     gainPGA[ch] = GET_PGA_GAIN(gains);
00204                     needUpdate = \textcolor{keyword}{true};
00205                 \}
00206             \}
00207             \textcolor{keywordflow}{if}(needUpdate)
00208             \{
00209                 uint16\_t reg126;
00210                 \textcolor{comment}{//set C\_CTL\_PGA\_RBB}
00211                 reg126 = GetValueOf_c_ctl_pga_rbb(gainPGA[ch]) << 11;
00212                 SPI_write(0x0126, reg126 | (gainPGA[ch] << 6) | (gainLNA[ch] << 2) | 2);
00213             \}
00214         \}
00215     \}
00216 AGC\_END:
00217     StoreState(\textcolor{keyword}{true});
00218     SPI_write(0x0020, x0020);
00219     ClockLogicResets();
00220     hasStopped = \textcolor{keyword}{true};
00221     \textcolor{keywordflow}{return} status;
00222 \}
\end{DoxyCode}
