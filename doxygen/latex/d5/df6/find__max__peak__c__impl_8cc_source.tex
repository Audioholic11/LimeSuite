\subsection{find\+\_\+max\+\_\+peak\+\_\+c\+\_\+impl.\+cc}
\label{find__max__peak__c__impl_8cc_source}\index{/home/erik/prefix/default/src/gr-\/radar-\/dev/lib/find\+\_\+max\+\_\+peak\+\_\+c\+\_\+impl.\+cc@{/home/erik/prefix/default/src/gr-\/radar-\/dev/lib/find\+\_\+max\+\_\+peak\+\_\+c\+\_\+impl.\+cc}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* -*- c++ -*- */}
00002 \textcolor{comment}{/* }
00003 \textcolor{comment}{ * Copyright 2014 Communications Engineering Lab, KIT.}
00004 \textcolor{comment}{ * }
00005 \textcolor{comment}{ * This is free software; you can redistribute it and/or modify}
00006 \textcolor{comment}{ * it under the terms of the GNU General Public License as published by}
00007 \textcolor{comment}{ * the Free Software Foundation; either version 3, or (at your option)}
00008 \textcolor{comment}{ * any later version.}
00009 \textcolor{comment}{ * }
00010 \textcolor{comment}{ * This software is distributed in the hope that it will be useful,}
00011 \textcolor{comment}{ * but WITHOUT ANY WARRANTY; without even the implied warranty of}
00012 \textcolor{comment}{ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
00013 \textcolor{comment}{ * GNU General Public License for more details.}
00014 \textcolor{comment}{ * }
00015 \textcolor{comment}{ * You should have received a copy of the GNU General Public License}
00016 \textcolor{comment}{ * along with this software; see the file COPYING.  If not, write to}
00017 \textcolor{comment}{ * the Free Software Foundation, Inc., 51 Franklin Street,}
00018 \textcolor{comment}{ * Boston, MA 02110-1301, USA.}
00019 \textcolor{comment}{ */}
00020 
00021 \textcolor{preprocessor}{#ifdef HAVE\_CONFIG\_H}
00022 \textcolor{preprocessor}{#include "config.h"}
00023 \textcolor{preprocessor}{#endif}
00024 
00025 \textcolor{preprocessor}{#include <gnuradio/io\_signature.h>}
00026 \textcolor{preprocessor}{#include "find_max_peak_c_impl.h"}
00027 
00028 \textcolor{keyword}{namespace }gr \{
00029   \textcolor{keyword}{namespace }radar \{
00030 
00031     find_max_peak_c::sptr
00032     find_max_peak_c::make(\textcolor{keywordtype}{int} samp_rate, \textcolor{keywordtype}{float} threshold, \textcolor{keywordtype}{int} samp\_protect, std::vector<float> max\_freq, \textcolor{keywordtype}{
      bool} cut\_max\_freq, \textcolor{keyword}{const} std::string& len\_key)
00033     \{
00034       \textcolor{keywordflow}{return} gnuradio::get\_initial\_sptr
00035         (\textcolor{keyword}{new} find_max_peak_c_impl(samp\_rate, threshold, samp\_protect, max\_freq, cut\_max\_freq, len\_key));
00036     \}
00037 
00038     \textcolor{comment}{/*}
00039 \textcolor{comment}{     * The private constructor}
00040 \textcolor{comment}{     */}
00041     find_max_peak_c_impl::find_max_peak_c_impl(\textcolor{keywordtype}{int} samp_rate, \textcolor{keywordtype}{float} threshold, \textcolor{keywordtype}{int} samp\_protect, 
      std::vector<float> max\_freq, \textcolor{keywordtype}{bool} cut\_max\_freq, \textcolor{keyword}{const} std::string& len\_key)
00042       : gr::tagged\_stream\_block(\textcolor{stringliteral}{"find\_max\_peak\_c"},
00043               gr::io\_signature::make(1,1,sizeof(gr\_complex)),
00044               gr::io\_signature::make(0,0,0),len\_key)
00045     \{
00046         d_samp_rate = samp_rate;
00047         d_threshold = threshold;
00048         d_samp_protect = samp\_protect;
00049         d_max_freq = max\_freq;
00050         d_cut_max_freq = cut\_max\_freq;
00051         
00052         \textcolor{comment}{// Register message port}
00053         d_port_id = pmt::mp(\textcolor{stringliteral}{"Msg out"});
00054         message\_port\_register\_out(d_port_id);
00055     \}
00056 
00057     \textcolor{comment}{/*}
00058 \textcolor{comment}{     * Our virtual destructor.}
00059 \textcolor{comment}{     */}
00060     find_max_peak_c_impl::~find_max_peak_c_impl()
00061     \{
00062     \}
00063 
00064     \textcolor{keywordtype}{int}
00065     find_max_peak_c_impl::calculate_output_stream_length(\textcolor{keyword}{const} gr\_vector\_int &ninput\_items)
00066     \{
00067       \textcolor{keywordtype}{int} noutput\_items = 0;
00068       \textcolor{keywordflow}{return} noutput\_items ;
00069     \}
00070     
00071     \textcolor{keywordtype}{void}
00072     find_max_peak_c_impl::set_threshold(\textcolor{keywordtype}{float} threshold)
00073     \{
00074       d_threshold = threshold;
00075     \}
00076     
00077     \textcolor{keywordtype}{void}
00078     find_max_peak_c_impl::set_samp_protect(\textcolor{keywordtype}{int} samp)
00079     \{
00080       d_samp_protect = samp;
00081     \}
00082     
00083     \textcolor{keywordtype}{void}
00084     find_max_peak_c_impl::set_max_freq(std::vector<float> freq)\{
00085         d_max_freq = freq;
00086     \}
00087 
00088     \textcolor{keywordtype}{int}
00089     find_max_peak_c_impl::work (\textcolor{keywordtype}{int} noutput\_items,
00090                        gr\_vector\_int &ninput\_items,
00091                        gr\_vector\_const\_void\_star &input\_items,
00092                        gr\_vector\_void\_star &output\_items)
00093     \{
00094         \textcolor{keyword}{const} gr\_complex *in = (\textcolor{keyword}{const} gr\_complex *) input\_items[0];
00095         
00096         \textcolor{comment}{// Find max peak detection}
00097         d_freq.clear();
00098         d_pks.clear();
00099         d_angle.clear();
00100         
00101         \textcolor{keywordtype}{int} k\_max\_pos, k\_max\_neg;
00102         \textcolor{keywordflow}{if}(d_cut_max_freq)\{
00103             k\_max\_pos = (ninput\_items[0]/float(d_samp_rate))*d_max_freq[1];
00104             k\_max\_neg = ninput\_items[0]+(ninput\_items[0]/float(d_samp_rate))*
      d_max_freq[0];
00105         \}
00106         \textcolor{keywordtype}{int} k = -1;
00107         \textcolor{keywordtype}{float} hold = -1;
00108         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} p=d_samp_protect; p<ninput\_items[0]-d_samp_protect; p++)\{ \textcolor{comment}{// implementation of protected
       samples}
00109             \textcolor{keywordflow}{if}(d_cut_max_freq)\{
00110                 \textcolor{keywordflow}{if}( p>k\_max\_pos && p<k\_max\_neg )\{ \textcolor{comment}{// skip frequency over abs(max\_freq)}
00111                     \textcolor{keywordflow}{continue};
00112                 \}
00113             \}
00114             \textcolor{keywordflow}{if}(std::pow(std::abs(in[p]),2)>hold && std::pow(std::abs(in[p]),2)>std::pow(10,
      d_threshold/10.0))\{
00115                 hold = std::pow(std::abs(in[p]),2);
00116                 k = p;
00117             \}
00118         \}
00119         
00120         \textcolor{keywordflow}{if}(k!=-1)\{
00121             \textcolor{keywordflow}{if}(k<=ninput\_items[0]/2) d_freq.push\_back(k*(d_samp_rate/(\textcolor{keywordtype}{float})ninput\_items[0])); \textcolor{comment}{// add
       frequency to message vector d\_freq}
00122             \textcolor{keywordflow}{else} d_freq.push\_back(-(\textcolor{keywordtype}{float})d_samp_rate+k*(d_samp_rate/(\textcolor{keywordtype}{float})ninput\_items[0]));
00123             d_pks.push\_back(std::pow(std::abs(in[k]),2));
00124             d_angle.push\_back(std::arg(in[k]));
00125         \}
00126 
00127         \textcolor{comment}{// get rx\_time tag}
00128         get\_tags\_in\_range(d_tags,0,nitems\_read(0),nitems\_read(0)+1,pmt::string\_to\_symbol(\textcolor{stringliteral}{"rx\_time"}));
00129         
00130         \textcolor{comment}{// setup msg pmt}
00131         \textcolor{keywordflow}{if}(d_tags.size()>0) d_ptimestamp = pmt::list2(pmt::string\_to\_symbol(\textcolor{stringliteral}{"rx\_time"}),
      d_tags[0].value);
00132         \textcolor{keywordflow}{else} d_ptimestamp = pmt::list2(pmt::string\_to\_symbol(\textcolor{stringliteral}{"rx\_time"}),pmt::make\_tuple(pmt::from\_uint64(0)
      ,pmt::from\_double(-1))); \textcolor{comment}{// if no timetag is found, set to 0 and frac\_sec to -1}
00133         d_pfreq = pmt::list2(pmt::string\_to\_symbol(\textcolor{stringliteral}{"frequency"}),pmt::init\_f32vector(
      d_freq.size(),d_freq));
00134         d_ppks = pmt::list2(pmt::string\_to\_symbol(\textcolor{stringliteral}{"power"}),pmt::init\_f32vector(
      d_pks.size(),d_pks));
00135         d_pangle = pmt::list2(pmt::string\_to\_symbol(\textcolor{stringliteral}{"phase"}),pmt::init\_f32vector(
      d_angle.size(),d_angle));
00136         d_value = pmt::list4(d_ptimestamp,d_pfreq,d_ppks,d_pangle);
00137         
00138         \textcolor{comment}{// publish message}
00139         message\_port\_pub(d_port_id,d_value);
00140 
00141         \textcolor{comment}{// Tell runtime system how many output items we produced.}
00142         \textcolor{keywordflow}{return} 0;
00143     \}
00144 
00145   \} \textcolor{comment}{/* namespace radar */}
00146 \} \textcolor{comment}{/* namespace gr */}
00147 
\end{DoxyCode}
