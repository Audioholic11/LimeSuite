\subsection{mcu\+Hex\+Bin.\+cpp}
\label{mcuHexBin_8cpp_source}\index{/home/erik/prefix/default/src/limesuite-\/dev/mcu\+\_\+program/host\+\_\+src/mcu\+Hex\+Bin.\+cpp@{/home/erik/prefix/default/src/limesuite-\/dev/mcu\+\_\+program/host\+\_\+src/mcu\+Hex\+Bin.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#include "mcuHexBin.h"}
00002 
00003 \textcolor{preprocessor}{#include <stdio.h>}
00004 \textcolor{preprocessor}{#include <stdbool.h>}
00005 \textcolor{preprocessor}{#include <string.h>}
00006 \textcolor{preprocessor}{#include <algorithm>}
00007 \textcolor{preprocessor}{#include <vector>}
00008 \textcolor{preprocessor}{#include <iostream>}
00009 \textcolor{keyword}{using namespace }std;
00010 
00011 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}
00012 \{
00013     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} m\_startAddress;
00014     std::vector<unsigned char> m_bytes;
00015 \} MemBlock;
00016 
00017 \textcolor{keywordtype}{int} MCU_HEX2BIN(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} uint16\_t limit, uint8\_t *binImage, uint16\_t *imgSize)
00018 \{
00019     vector<MemBlock>    m\_chunks;
00020     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}       m\_top;
00021 
00022     FILE* m\_file = fopen(filename, \textcolor{stringliteral}{"r"});
00023     \textcolor{keywordflow}{if} (m\_file == NULL)
00024     \{
00025         printf(\textcolor{stringliteral}{"File not found: %s\(\backslash\)n"}, filename);
00026         \textcolor{keywordflow}{return} -1;
00027     \}
00028     memset(binImage, 0, limit);
00029 
00030     \textcolor{keyword}{const} uint16\_t cMaxLineLen = 1024;
00031     \textcolor{keywordtype}{char} szLine[cMaxLineLen];
00032     \textcolor{keywordtype}{bool} endSeen = \textcolor{keyword}{false};
00033     \textcolor{keywordtype}{bool} linear = \textcolor{keyword}{true};             \textcolor{comment}{// Only used for intel hex}
00034     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} addressBase = 0;  \textcolor{comment}{// Only used for intel hex}
00035     \textcolor{keywordflow}{while}(!feof(m\_file))
00036     \{
00037         \textcolor{comment}{//memset(szLine, 0, cMaxLineLen);}
00038         \textcolor{keywordflow}{if}(fgets(szLine, cMaxLineLen, m\_file) == 0)
00039         \{
00040             \textcolor{keywordflow}{if} (ferror(m\_file))
00041                 printf(\textcolor{stringliteral}{"Error reading input!\(\backslash\)n"});
00042             \textcolor{keywordflow}{continue};
00043         \}
00044 
00045         \textcolor{comment}{//clear \(\backslash\)r\(\backslash\)n}
00046         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<2; ++i)
00047         \{
00048             \textcolor{keywordtype}{int} lastCharPos = strlen(szLine)-1;
00049             \textcolor{keywordflow}{if} (szLine[lastCharPos] == \textcolor{charliteral}{'\(\backslash\)n'} || szLine[lastCharPos] == \textcolor{charliteral}{'\(\backslash\)r'})
00050                 szLine[lastCharPos] = 0;
00051         \}
00052 
00053         \textcolor{keywordflow}{if} (strlen(szLine) == cMaxLineLen-1)
00054         \{
00055             printf(\textcolor{stringliteral}{"Hex file lines to long!\(\backslash\)n"});
00056             \textcolor{keywordflow}{return} -2;
00057         \}
00058         \textcolor{comment}{// Ignore blank lines}
00059         \textcolor{keywordflow}{if} (szLine[0] == \textcolor{charliteral}{'\(\backslash\)n'} || szLine[0] == \textcolor{charliteral}{'\(\backslash\)r'})
00060             \textcolor{keywordflow}{continue};
00061 
00062         \textcolor{comment}{// Detect format and warn if garbage lines are found}
00063         \textcolor{keywordflow}{if} (szLine[0] != \textcolor{charliteral}{':'})
00064         \{
00065             printf(\textcolor{stringliteral}{"Ignoring garbage line!\(\backslash\)n"});
00066             \textcolor{keywordflow}{continue};
00067         \}
00068 
00069         \textcolor{keywordflow}{if}(endSeen)
00070         \{
00071             printf(\textcolor{stringliteral}{"Hex line after end of file record!\(\backslash\)n"});
00072             \textcolor{keywordflow}{return} -3;
00073         \}
00074 
00075         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dataBytes;
00076         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} startAddress;
00077         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} type;
00078         \textcolor{keywordflow}{if}(sscanf(&szLine[1], \textcolor{stringliteral}{"%2lx%4lx%2lx"}, &dataBytes, &startAddress, &type) != 3)
00079         \{
00080             printf(\textcolor{stringliteral}{"Hex line beginning corrupt!\(\backslash\)n"});
00081             \textcolor{keywordflow}{return} -4;
00082         \}
00083         \textcolor{comment}{// Check line length}
00084         \textcolor{keywordflow}{if} (szLine[11 + dataBytes * 2] != \textcolor{charliteral}{'\(\backslash\)n'} && szLine[11 + dataBytes * 2] != 0)
00085         \{
00086             printf(\textcolor{stringliteral}{"Hex line length incorrect!\(\backslash\)n"});
00087             \textcolor{keywordflow}{return} -6;
00088         \}
00089         \textcolor{comment}{// Check line checksum}
00090         uint8\_t checkSum = 0;
00091         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} tmp;
00092         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i <= dataBytes + 4; ++i)
00093         \{
00094             \textcolor{keywordflow}{if} (sscanf(&szLine[1 + i * 2], \textcolor{stringliteral}{"%2lx"}, &tmp) != 1)
00095             \{
00096                 printf(\textcolor{stringliteral}{"Hex line data corrupt!\(\backslash\)n"});
00097                 \textcolor{keywordflow}{return} -7;
00098             \}
00099             checkSum += tmp;
00100         \}
00101         \textcolor{keywordflow}{if} (checkSum != 0)
00102         \{
00103             printf(\textcolor{stringliteral}{"Hex line checksum error!\(\backslash\)n"});
00104             \textcolor{keywordflow}{return} -8;
00105         \}
00106 
00107         \textcolor{keywordflow}{switch} (type)
00108         \{
00109         \textcolor{keywordflow}{case} 0: \textcolor{comment}{// Data record}
00110             \textcolor{keywordflow}{if} (!linear)
00111             \{
00112                 \textcolor{comment}{// Segmented}
00113                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} test = startAddress;
00114                 test += dataBytes;
00115                 \textcolor{keywordflow}{if} (test > 0xffff)
00116                 \{
00117                     printf(\textcolor{stringliteral}{"Can't handle wrapped segments!\(\backslash\)n"});
00118                     \textcolor{keywordflow}{return} -9;
00119                 \}
00120             \}
00121             \textcolor{keywordflow}{if} (!m\_chunks.size() ||
00122                 m\_chunks.back().m\_startAddress + m\_chunks.back().m\_bytes.size() !=
00123                 addressBase + startAddress)
00124             \{
00125                 m\_chunks.push\_back(MemBlock());
00126                 m\_chunks.back().m\_startAddress = addressBase + startAddress;
00127             \}
00128             \{
00129                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} i = 0;
00130                 \textcolor{keywordflow}{for} (i = 0; i < dataBytes; ++i)
00131                 \{
00132                     sscanf(&szLine[9 + i * 2], \textcolor{stringliteral}{"%2lx"}, &tmp);
00133                     \textcolor{keywordflow}{if} (addressBase + startAddress + i > limit)
00134                     \{
00135                         cout << \textcolor{stringliteral}{"Ignoring data above address space!\(\backslash\)n"};
00136                         cout << \textcolor{stringliteral}{"Data address: "} << addressBase + startAddress + 
      i;
00137                         cout << \textcolor{stringliteral}{" Limit: "} << limit << \textcolor{stringliteral}{"\(\backslash\)n"};
00138                         \textcolor{keywordflow}{if} (!m\_chunks.back().m\_bytes.size())
00139                         \{
00140                             m\_chunks.pop\_back();
00141                         \}
00142                         \textcolor{keywordflow}{continue};
00143                     \}
00144                     m\_chunks.back().m\_bytes.push\_back(tmp);
00145                 \}
00146             \}
00147             \textcolor{keywordflow}{break};
00148 
00149         \textcolor{keywordflow}{case} 1: \textcolor{comment}{// End-of-file record}
00150             \textcolor{keywordflow}{if} (dataBytes != 0)
00151                 printf(\textcolor{stringliteral}{"Warning: End of file record not zero length!\(\backslash\)n"});
00152             \textcolor{keywordflow}{if} (startAddress != 0)
00153                 printf(\textcolor{stringliteral}{"Warning: End of file record address not zero!\(\backslash\)n"});
00154             endSeen = \textcolor{keyword}{true};
00155             \textcolor{keywordflow}{break};
00156 
00157         \textcolor{keywordflow}{case} 2: \textcolor{comment}{// Extended segment address record}
00158             \textcolor{keywordflow}{if}(dataBytes != 2)
00159             \{
00160                 printf(\textcolor{stringliteral}{"Length field must be 2 in extended segment address record!\(\backslash\)n"});
00161                 \textcolor{keywordflow}{return} -10;
00162             \}
00163             \textcolor{keywordflow}{if} (startAddress != 0)
00164             \{
00165                 printf(\textcolor{stringliteral}{"Address field must be zero in extended segment address record!\(\backslash\)n"});
00166                 \textcolor{keywordflow}{return} -11;
00167             \}
00168             sscanf(&szLine[9], \textcolor{stringliteral}{"%4lx"}, &startAddress);
00169             addressBase = startAddress << 4;
00170             linear = \textcolor{keyword}{false};
00171             \textcolor{keywordflow}{break};
00172 
00173         \textcolor{keywordflow}{case} 3: \textcolor{comment}{// Start segment address record}
00174             \textcolor{keywordflow}{if} (dataBytes != 4)
00175                 printf(\textcolor{stringliteral}{"Warning: Length field must be 4 in start segment address record!\(\backslash\)n"});
00176             \textcolor{keywordflow}{if} (startAddress != 0)
00177                 printf(\textcolor{stringliteral}{"Warning: Address field must be zero in start segment address record!\(\backslash\)n"});
00178             \textcolor{keywordflow}{if} (dataBytes == 4)
00179             \{
00180                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} ssa;
00181                 \textcolor{keywordtype}{char}    ssaStr[16];
00182                 sscanf(&szLine[9], \textcolor{stringliteral}{"%8lx"}, &ssa);
00183                 sprintf(ssaStr, \textcolor{stringliteral}{"%08lX\(\backslash\)n"}, ssa);
00184                 cout << \textcolor{stringliteral}{"Segment start address (CS/IP): "};
00185                 cout << ssaStr;
00186             \}
00187             \textcolor{keywordflow}{break};
00188 
00189         \textcolor{keywordflow}{case} 4: \textcolor{comment}{// Extended linear address record}
00190             \textcolor{keywordflow}{if} (dataBytes != 2)
00191             \{
00192                 printf(\textcolor{stringliteral}{"Length field must be 2 in extended linear address record!\(\backslash\)n"});
00193                 \textcolor{keywordflow}{return} -12;
00194             \}
00195             \textcolor{keywordflow}{if} (startAddress != 0)
00196             \{
00197                 printf(\textcolor{stringliteral}{"Address field must be zero in extended linear address record!\(\backslash\)n"});
00198                 \textcolor{keywordflow}{return} -13;
00199             \}
00200             sscanf(&szLine[9], \textcolor{stringliteral}{"%4lx"}, &startAddress);
00201             addressBase = ((\textcolor{keywordtype}{unsigned} long)startAddress) << 16;
00202             linear = \textcolor{keyword}{true};
00203             \textcolor{keywordflow}{break};
00204 
00205         \textcolor{keywordflow}{case} 5: \textcolor{comment}{// Start linear address record}
00206             \textcolor{keywordflow}{if} (dataBytes != 4)
00207                 printf(\textcolor{stringliteral}{"Warning: Length field must be 4 in start linear address record!\(\backslash\)n"});
00208             \textcolor{keywordflow}{if} (startAddress != 0)
00209                 printf(\textcolor{stringliteral}{"Warning: Address field must be zero in start linear address record!\(\backslash\)n"});
00210             \textcolor{keywordflow}{if} (dataBytes == 4)
00211             \{
00212                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} lsa;
00213                 \textcolor{keywordtype}{char}    lsaStr[16];
00214                 sscanf(&szLine[9], \textcolor{stringliteral}{"%8lx"}, &lsa);
00215                 sprintf(lsaStr, \textcolor{stringliteral}{"%08lX\(\backslash\)n"}, lsa);
00216                 cout << \textcolor{stringliteral}{"Linear start address: "};
00217                 cout << lsaStr;
00218             \}
00219             \textcolor{keywordflow}{break};
00220 
00221         \textcolor{keywordflow}{default}:
00222             printf(\textcolor{stringliteral}{"Waring: Unknown record found!\(\backslash\)n"});
00223         \}
00224     \}
00225     \textcolor{keywordflow}{if} (!endSeen)
00226         printf(\textcolor{stringliteral}{"No end of file record!\(\backslash\)n"});
00227     \textcolor{keywordflow}{if} (!m\_chunks.size())
00228     \{
00229         printf(\textcolor{stringliteral}{"No data in file!\(\backslash\)n"});
00230         \textcolor{keywordflow}{return} -14;
00231     \}
00232     vector<MemBlock>::iterator  vi;
00233     m\_top = 0;
00234     \textcolor{keywordflow}{for} (vi = m\_chunks.begin(); vi < m\_chunks.end(); vi++)
00235     \{
00236         m\_top = std::max<size\_t>(m\_top, vi->m\_startAddress + vi->m\_bytes.size() - 1);
00237     \}
00238     \textcolor{keywordflow}{if}(binImage)
00239     \{
00240         memset(binImage, 0, limit);
00241         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i : m\_chunks)
00242         \{
00243             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} j=0; j<i.m\_bytes.size(); ++j)
00244                 \textcolor{keywordflow}{if}(i.m\_startAddress+j < limit)
00245                     binImage[i.m\_startAddress+j] = i.m\_bytes[j];
00246         \}
00247     \}
00248     \textcolor{keywordflow}{if}(imgSize)
00249         *imgSize = m\_top;
00250     \textcolor{keywordflow}{return} 0;
00251 \}
\end{DoxyCode}
