\subsection{Streamer.\+cpp}
\label{Streamer_8cpp_source}\index{/home/erik/prefix/default/src/limesuite-\/dev/src/protocols/\+Streamer.\+cpp@{/home/erik/prefix/default/src/limesuite-\/dev/src/protocols/\+Streamer.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#include <assert.h>}
00002 \textcolor{preprocessor}{#include "FPGA_common.h"}
00003 \textcolor{preprocessor}{#include "LMS7002M.h"}
00004 \textcolor{preprocessor}{#include <ciso646>}
00005 \textcolor{preprocessor}{#include "Logger.h"}
00006 \textcolor{preprocessor}{#include "Streamer.h"}
00007 \textcolor{preprocessor}{#include "IConnection.h"}
00008 \textcolor{preprocessor}{#include <complex>}
00009 
00010 \textcolor{keyword}{namespace }lime
00011 \{
00012 
00013 StreamChannel::StreamChannel(Streamer* streamer) :
00014     mActive(false)
00015 \{
00016     mStreamer = streamer;
00017     overflow = 0;
00018     underflow = 0;
00019     pktLost = 0;
00020     fifo = \textcolor{keyword}{nullptr};
00021     used = \textcolor{keyword}{false};
00022 \}
00023 
00024 StreamChannel::~StreamChannel()
00025 \{
00026     \textcolor{keywordflow}{if} (fifo)
00027         \textcolor{keyword}{delete} fifo;
00028 \}
00029 
00030 \textcolor{keywordtype}{void} StreamChannel::Setup(StreamConfig conf)
00031 \{
00032     used = \textcolor{keyword}{true};
00033     config = conf;
00034     overflow = 0;
00035     underflow = 0;
00036     pktLost = 0;
00037     \textcolor{keywordflow}{if} (config.bufferLength == 0) \textcolor{comment}{//default size}
00038         config.bufferLength = 1024*8*SamplesPacket::maxSamplesInPacket;
00039     \textcolor{keywordflow}{else}
00040     \{
00041         \textcolor{keywordtype}{size\_t} fifoSize = 64;
00042         \textcolor{keywordflow}{while}(fifoSize < conf.bufferLength/SamplesPacket::maxSamplesInPacket)
00043             fifoSize <<= 1;
00044         this->config.bufferLength = fifoSize*SamplesPacket::maxSamplesInPacket;
00045     \}
00046     \textcolor{keywordflow}{if} (fifo)
00047         \textcolor{keyword}{delete} fifo;
00048     fifo = \textcolor{keyword}{new} RingFIFO(config.bufferLength);
00049 \}
00050 
00051 \textcolor{keywordtype}{void} StreamChannel::Close()
00052 \{
00053     \textcolor{keywordflow}{if} (mActive)
00054         Stop();
00055     \textcolor{keywordflow}{if} (fifo)
00056         \textcolor{keyword}{delete} fifo;
00057     fifo = \textcolor{keyword}{nullptr};
00058     used = \textcolor{keyword}{false};
00059 \}
00060 
00061 \textcolor{keywordtype}{int} StreamChannel::Write(\textcolor{keyword}{const} \textcolor{keywordtype}{void}* samples, \textcolor{keyword}{const} uint32\_t count, \textcolor{keyword}{const} 
      Metadata *meta, \textcolor{keyword}{const} int32\_t timeout_ms)
00062 \{
00063     \textcolor{keywordtype}{int} pushed = 0;
00064     \textcolor{keywordflow}{if}(config.format == StreamConfig::FMT_FLOAT32 && config.isTx)
00065     \{
00066         \textcolor{keyword}{const} \textcolor{keywordtype}{float}* samplesFloat = (\textcolor{keyword}{const} \textcolor{keywordtype}{float}*)samples;
00067         int16\_t* samplesShort = \textcolor{keyword}{new} int16\_t[2*count];
00068         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i=0; i<2*count; ++i)
00069             samplesShort[i] = samplesFloat[i]*32767.0f;
00070         \textcolor{keyword}{const} complex16_t* ptr = (\textcolor{keyword}{const} complex16_t*)samplesShort ;
00071         pushed = fifo->push_samples(ptr, count, 1, meta->timestamp, timeout\_ms, meta->
      flags);
00072         \textcolor{keyword}{delete}[] samplesShort;
00073     \}
00074     \textcolor{keywordflow}{else}
00075     \{
00076         \textcolor{keyword}{const} complex16_t* ptr = (\textcolor{keyword}{const} complex16_t*)samples;
00077         pushed = fifo->push_samples(ptr, count, 1, meta->timestamp, timeout\_ms, meta->
      flags);
00078     \}
00079     \textcolor{keywordflow}{return} pushed;
00080 \}
00081 
00082 \textcolor{keywordtype}{int} StreamChannel::Read(\textcolor{keywordtype}{void}* samples, \textcolor{keyword}{const} uint32\_t count, Metadata* meta, \textcolor{keyword}{const} int32\_t 
      timeout_ms)
00083 \{
00084     \textcolor{keywordtype}{int} popped = 0;
00085     \textcolor{keywordflow}{if}(config.format == StreamConfig::FMT_FLOAT32 && !config.isTx)
00086     \{
00087         \textcolor{comment}{//in place conversion}
00088         complex16_t* ptr = (complex16_t*)samples;
00089         int16\_t* samplesShort = (int16\_t*)samples;
00090         \textcolor{keywordtype}{float}* samplesFloat = (\textcolor{keywordtype}{float}*)samples;
00091         popped = fifo->pop_samples(ptr, count, 1, &meta->timestamp, timeout\_ms, &meta->
      flags);
00092         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=2*popped-1; i>=0; --i)
00093             samplesFloat[i] = (\textcolor{keywordtype}{float})samplesShort[i]/32767.0f;
00094     \}
00095     \textcolor{keywordflow}{else}
00096     \{
00097         complex16_t* ptr = (complex16_t*)samples;
00098         popped = fifo->pop_samples(ptr, count, 1, &meta->timestamp, timeout\_ms, &meta->
      flags);
00099     \}
00100     \textcolor{keywordflow}{return} popped;
00101 \}
00102 
00103 StreamChannel::Info StreamChannel::GetInfo()
00104 \{
00105     Info stats;
00106     memset(&stats,0,\textcolor{keyword}{sizeof}(stats));
00107     RingFIFO::BufferInfo info = fifo->GetInfo();
00108     stats.fifoSize = info.size;
00109     stats.fifoItemsCount = info.itemsFilled;
00110     stats.active = mActive;
00111     stats.droppedPackets = pktLost;
00112     stats.overrun = overflow;
00113     stats.overrun = underflow;
00114     pktLost = 0;
00115     overflow = 0;
00116     underflow = 0;
00117     \textcolor{keywordflow}{if}(config.isTx)
00118     \{
00119         stats.timestamp = mStreamer->txLastTimestamp;
00120         stats.linkRate = mStreamer->txDataRate_Bps.load();
00121     \}
00122     \textcolor{keywordflow}{else}
00123     \{
00124         stats.timestamp = mStreamer->rxLastTimestamp;
00125         stats.linkRate = mStreamer->rxDataRate_Bps.load();
00126     \}
00127     \textcolor{keywordflow}{return} stats;
00128 \}
00129 
00130 \textcolor{keywordtype}{int} StreamChannel::GetStreamSize()
00131 \{
00132     \textcolor{keywordflow}{return} mStreamer->GetStreamSize(config.isTx);
00133 \}
00134 
00135 \textcolor{keywordtype}{bool} StreamChannel::IsActive()\textcolor{keyword}{ const}
00136 \textcolor{keyword}{}\{
00137     \textcolor{keywordflow}{return} mActive;
00138 \}
00139 
00140 \textcolor{keywordtype}{int} StreamChannel::Start()
00141 \{
00142     mActive = \textcolor{keyword}{true};
00143     fifo->Clear();
00144     overflow = 0;
00145     underflow = 0;
00146     pktLost = 0;
00147     \textcolor{keywordflow}{return} mStreamer->UpdateThreads();
00148 \}
00149 
00150 \textcolor{keywordtype}{int} StreamChannel::Stop()
00151 \{
00152     mActive = \textcolor{keyword}{false};
00153     \textcolor{keywordflow}{return} mStreamer->UpdateThreads();
00154 \}
00155 
00156 Streamer::Streamer(FPGA* f, LMS7002M* chip, \textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) : mRxStreams(2, this), mTxStreams(2, this)
00157 \{
00158     lms = chip,
00159     fpga = f;
00160     chipId = id;
00161     dataPort = f->GetConnection();
00162     mTimestampOffset = 0;
00163     rxLastTimestamp = 0;
00164     terminateRx = \textcolor{keyword}{false};
00165     terminateTx = \textcolor{keyword}{false};
00166     rxDataRate_Bps = 0;
00167     txDataRate_Bps = 0;
00168     txBatchSize = 1;
00169     rxBatchSize = 1;
00170     streamSize = 1;
00171 \}
00172 
00173 Streamer::~Streamer()
00174 \{
00175     terminateTx.store(\textcolor{keyword}{true});
00176     \textcolor{keywordflow}{if} (txThread.joinable())
00177         txThread.join();
00178     terminateRx.store(\textcolor{keyword}{true});
00179     \textcolor{keywordflow}{if} (rxThread.joinable())
00180         rxThread.join();
00181 \}
00182 
00183 
00184 StreamChannel* Streamer::SetupStream(\textcolor{keyword}{const} StreamConfig& config)
00185 \{
00186     \textcolor{keyword}{const} \textcolor{keywordtype}{int} ch = config.channelID&1;
00187 
00188     \textcolor{keywordflow}{if} ((config.isTx && mTxStreams[ch].used) || (!config.isTx && mRxStreams[ch].used))
00189     \{
00190         lime::error(\textcolor{stringliteral}{"Setup Stream: Channel already in use"});
00191         \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
00192     \}
00193 
00194     \textcolor{keywordflow}{if} ((!mTxStreams[ch].used) && (!mRxStreams[ch].used) && (txThread.joinable() || 
      rxThread.joinable()))
00195     \{
00196         lime::warning(\textcolor{stringliteral}{"Stopping data stream to set up a new stream"});
00197         UpdateThreads(\textcolor{keyword}{true});
00198     \}
00199 
00200 
00201     \textcolor{keywordflow}{if}(config.isTx)
00202         mTxStreams[ch].Setup(config);
00203     \textcolor{keywordflow}{else}
00204         mRxStreams[ch].Setup(config);
00205 
00206     \textcolor{keywordtype}{double} rate = lms->GetSampleRate(config.isTx,LMS7002M::ChA)/1e6;
00207     streamSize = (mTxStreams[0].used||mRxStreams[0].used) + (mTxStreams[1].used||
      mRxStreams[1].used);
00208 
00209     rate = (rate + 5) * config.performanceLatency * streamSize;
00210     for (\textcolor{keywordtype}{int} batch = 1; batch < rate; batch <<= 1)
00211         \textcolor{keywordflow}{if} (config.isTx)
00212             txBatchSize = batch;
00213         \textcolor{keywordflow}{else}
00214             rxBatchSize = batch;
00215 
00216     \textcolor{keywordflow}{return} config.isTx ? &mTxStreams[ch] : &mRxStreams[ch]; \textcolor{comment}{//success}
00217 \}
00218 
00219 \textcolor{keywordtype}{int} Streamer::GetStreamSize(\textcolor{keywordtype}{bool} tx)
00220 \{
00221     \textcolor{keywordtype}{int} batchSize = (tx ? txBatchSize : rxBatchSize)/streamSize;
00222     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &i : mRxStreams)
00223         \textcolor{keywordflow}{if}(i.used && i.config.format != StreamConfig::FMT_INT12)
00224             \textcolor{keywordflow}{return} samples16InPkt*batchSize;
00225 
00226     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &i : mTxStreams)
00227         \textcolor{keywordflow}{if}(i.used && i.config.format != StreamConfig::FMT_INT12)
00228             \textcolor{keywordflow}{return} samples16InPkt*batchSize;
00229 
00230     \textcolor{keywordflow}{return} samples12InPkt*batchSize;
00231 \}
00232 
00233 uint64\_t Streamer::GetHardwareTimestamp(\textcolor{keywordtype}{void})
00234 \{
00235     \textcolor{keywordflow}{if}(!(rxThread.joinable() || txThread.joinable()))
00236     \{
00237         \textcolor{comment}{//stop streaming just in case the board has not been configured}
00238         dataPort->WriteRegister(0xFFFF, 1 << chipId);
00239         fpga->StopStreaming();
00240         fpga->ResetTimestamp();
00241         mTimestampOffset = 0;
00242         \textcolor{keywordflow}{return} 0;
00243     \}
00244     \textcolor{keywordflow}{else}
00245     \{
00246         \textcolor{keywordflow}{return} rxLastTimestamp.load()+mTimestampOffset;
00247     \}
00248 \}
00249 
00250 \textcolor{keywordtype}{void} Streamer::SetHardwareTimestamp(\textcolor{keyword}{const} uint64\_t now)
00251 \{
00252     mTimestampOffset = now - rxLastTimestamp.load();
00253 \}
00254 
00255 \textcolor{keywordtype}{void} Streamer::RstRxIQGen()
00256 \{
00257     uint32\_t data[16];
00258     uint32\_t reg20;
00259     uint32\_t reg11C;
00260     uint32\_t reg10C;
00261     data[0] = (uint32\_t(0x0020) << 16);
00262     dataPort->ReadLMS7002MSPI(data, &reg20, 1, chipId);
00263     data[0] = (uint32\_t(0x010C) << 16);
00264     dataPort->ReadLMS7002MSPI(data, &reg10C, 1, chipId);
00265     data[0] = (1 << 31) | (uint32\_t(0x0020) << 16) | 0xFFFD;
00266     dataPort->WriteLMS7002MSPI(data, 1, chipId);
00267     data[0] = (uint32\_t(0x011C) << 16);
00268     dataPort->ReadLMS7002MSPI(data, &reg11C, 1, chipId);
00269     data[0] = (1 << 31) | (uint32\_t(0x0020) << 16) | 0xFFFD;             \textcolor{comment}{//SXR}
00270     data[1] = (1 << 31) | (uint32\_t(0x011C) << 16) | (reg11C | 0x10);    \textcolor{comment}{//PD\_FDIV}
00271     data[2] = (1 << 31) | (uint32\_t(0x0020) << 16) | 0xFFFF;             \textcolor{comment}{// mac 3 - both channels}
00272     data[3] = (1 << 31) | (uint32\_t(0x0124) << 16) | 0x001F;             \textcolor{comment}{//direct control of powerdowns}
00273     data[4] = (1 << 31) | (uint32\_t(0x010C) << 16) | (reg10C | 0x8);     \textcolor{comment}{// PD\_QGEN\_RFE}
00274     data[5] = (1 << 31) | (uint32\_t(0x010C) << 16) | reg10C;             \textcolor{comment}{//restore value}
00275     data[6] = (1 << 31) | (uint32\_t(0x0020) << 16) | 0xFFFD;             \textcolor{comment}{//SXR}
00276     data[7] = (1 << 31) | (uint32\_t(0x011C) << 16) | reg11C;             \textcolor{comment}{//restore value}
00277     data[8] = (1 << 31) | (uint32\_t(0x0020) << 16) | reg20;              \textcolor{comment}{//restore value}
00278     dataPort->WriteLMS7002MSPI(data, 9, chipId);
00279 \}
00280 
00281 \textcolor{keywordtype}{void} Streamer::AlignRxTSP()
00282 \{
00283     uint32\_t reg20;
00284     uint32\_t regsA[2];
00285     uint32\_t regsB[2];
00286     \textcolor{comment}{//backup values}
00287     \{
00288         \textcolor{keyword}{const} std::vector<uint32\_t> bakAddr = \{ (uint32\_t(0x0400) << 16), (uint32\_t(0x040C) << 16) \};
00289         uint32\_t data = (uint32\_t(0x0020) << 16);
00290         dataPort->ReadLMS7002MSPI(&data, &reg20, 1, chipId);
00291         data = (uint32\_t(0x0020) << 16) | 0xFFFD;
00292         dataPort->WriteLMS7002MSPI(&data, 1, chipId);
00293         dataPort->ReadLMS7002MSPI(bakAddr.data(), regsA, bakAddr.size(), chipId);
00294         data = (uint32\_t(0x0020) << 16) | 0xFFFE;
00295         dataPort->WriteLMS7002MSPI(&data, 1, chipId);
00296         dataPort->ReadLMS7002MSPI(bakAddr.data(), regsB, bakAddr.size(), chipId);
00297     \}
00298 
00299     \textcolor{comment}{//alignment search}
00300     \{
00301         uint32\_t dataWr[4];
00302         dataWr[0] = (1 << 31) | (uint32\_t(0x0020) << 16) | 0xFFFF;
00303         dataWr[1] = (1 << 31) | (uint32\_t(0x0400) << 16) | 0x8085;
00304         dataWr[2] = (1 << 31) | (uint32\_t(0x040C) << 16) | 0x01FF;
00305         dataPort->WriteLMS7002MSPI(dataWr, 3, chipId);
00306         uint32\_t* buf = \textcolor{keyword}{new} uint32\_t[\textcolor{keyword}{sizeof}(FPGA_DataPacket) / \textcolor{keyword}{sizeof}(uint32\_t)];
00307 
00308         fpga->StopStreaming();
00309         dataPort->WriteRegister(0xFFFF, 1 << chipId);
00310         dataPort->WriteRegister(0x0008, 0x0100);
00311         dataPort->WriteRegister(0x0007, 3);
00312 
00313         dataWr[0] = (1 << 31) | (uint32\_t(0x0020) << 16) | 0x55FE;
00314         dataWr[1] = (1 << 31) | (uint32\_t(0x0020) << 16) | 0xFFFD;
00315 
00316         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 100; i++)
00317         \{
00318             dataPort->WriteLMS7002MSPI(&dataWr[0], 2, chipId);
00319             dataPort->ResetStreamBuffers();
00320             fpga->StartStreaming();
00321             \textcolor{keywordflow}{if} (dataPort->ReceiveData((\textcolor{keywordtype}{char}*)buf, \textcolor{keyword}{sizeof}(FPGA_DataPacket), 
      chipId, 50) != \textcolor{keyword}{sizeof}(FPGA_DataPacket))
00322             \{
00323                 lime::warning(\textcolor{stringliteral}{"Channel alignment failed"});
00324                 \textcolor{keywordflow}{break};
00325             \}
00326             fpga->StopStreaming();
00327             dataPort->AbortReading(chipId);
00328             \textcolor{keywordflow}{if} (buf[4] == buf[5])
00329                 \textcolor{keywordflow}{break};
00330         \}
00331         \textcolor{keyword}{delete}[] buf;
00332     \}
00333 
00334     \textcolor{comment}{//restore values}
00335     \{
00336         uint32\_t dataWr[7];
00337         dataWr[0] = (uint32\_t(0x0020) << 16) | 0xFFFD;
00338         dataWr[1] = (uint32\_t(0x0400) << 16) | regsA[0];
00339         dataWr[2] = (uint32\_t(0x040C) << 16) | regsA[1];
00340         dataWr[3] = (uint32\_t(0x0020) << 16) | 0xFFFE;
00341         dataWr[4] = (uint32\_t(0x0400) << 16) | regsB[0];
00342         dataWr[5] = (uint32\_t(0x040C) << 16) | regsB[1];
00343         dataWr[6] = (uint32\_t(0x0020) << 16) | reg20;
00344         dataPort->WriteLMS7002MSPI(dataWr, 7, chipId);
00345     \}
00346 \}
00347 
00348 \textcolor{keywordtype}{double} Streamer::GetPhaseOffset(\textcolor{keywordtype}{int} bin)
00349 \{
00350     int16\_t* buf = \textcolor{keyword}{new} int16\_t[\textcolor{keyword}{sizeof}(FPGA_DataPacket)/\textcolor{keyword}{sizeof}(int16\_t)];
00351 
00352     dataPort->ResetStreamBuffers();
00353     fpga->StartStreaming();
00354     \textcolor{keywordflow}{if} (dataPort->ReceiveData((\textcolor{keywordtype}{char}*)buf, \textcolor{keyword}{sizeof}(FPGA_DataPacket), chipId, 50)!=\textcolor{keyword}{sizeof}(
      FPGA_DataPacket))
00355     \{
00356         lime::warning(\textcolor{stringliteral}{"Channel alignment failed"});
00357         \textcolor{keyword}{delete} [] buf;
00358         \textcolor{keywordflow}{return} -1000;
00359     \}
00360     fpga->StopStreaming();
00361     dataPort->AbortReading(chipId);
00362     \textcolor{comment}{//calculate DFT bin of interest and check channel phase difference}
00363     \textcolor{keyword}{const} std::complex<double> iunit(0, 1);
00364     \textcolor{keyword}{const} \textcolor{keywordtype}{double} pi = std::acos(-1);
00365     \textcolor{keyword}{const} \textcolor{keywordtype}{int} N = 512;
00366     std::complex<double> xA(0,0);
00367     std::complex<double> xB(0, 0);
00368     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} n = 0; n < N; n++)
00369     \{
00370         \textcolor{keyword}{const} std::complex<double> xAn(buf[8+4*n], buf[9+4*n]);
00371         \textcolor{keyword}{const} std::complex<double> xBn(buf[10+4*n],buf[11+4*n]);
00372         \textcolor{keyword}{const} std::complex<double> mult = std::exp(-2.0*iunit*pi* \textcolor{keywordtype}{double}(bin)* \textcolor{keywordtype}{double}(n)/\textcolor{keywordtype}{double}(N));
00373         xA += xAn * mult;
00374         xB += xBn * mult;
00375     \}
00376     \textcolor{keywordtype}{double} phaseA = std::arg(xA) * 180.0 / pi;
00377     \textcolor{keywordtype}{double} phaseB = std::arg(xB) * 180.0 / pi;
00378     \textcolor{keywordtype}{double} phasediff = phaseB - phaseA;
00379     \textcolor{keywordflow}{if} (phasediff < -180.0) phasediff +=360.0;
00380     \textcolor{keywordflow}{if} (phasediff > 180.0) phasediff -=360.0;
00381     \textcolor{keyword}{delete} [] buf;
00382     \textcolor{keywordflow}{return} phasediff;
00383 \}
00384 
00385 \textcolor{keywordtype}{void} Streamer::AlignRxRF(\textcolor{keywordtype}{bool} restoreValues)
00386 \{
00387     uint32\_t addr = 0, val =0;
00388     dataPort->ReadRegisters(&addr,&val,1);
00389     \textcolor{keywordflow}{if} (val==0x10) \textcolor{comment}{//does not work on LimeSDR-QPCIE}
00390         \textcolor{keywordflow}{return};
00391     uint32\_t reg20 = lms->SPI_read(0x20);
00392     \textcolor{keyword}{auto} regBackup = lms->BackupRegisterMap();
00393     lms->SPI_write(0x20, 0xFFFF);
00394     lms->SetDefaults(LMS7002M::RFE);
00395     lms->SetDefaults(LMS7002M::RBB);
00396     lms->SetDefaults(LMS7002M::TBB);
00397     lms->SetDefaults(LMS7002M::TRF);
00398     lms->SPI_write(0x10C, 0x88C5);
00399     lms->SPI_write(0x10D, 0x0117);
00400     lms->SPI_write(0x113, 0x024A);
00401     lms->SPI_write(0x118, 0x418C);
00402     lms->SPI_write(0x100, 0x4039);
00403     lms->SPI_write(0x101, 0x7801);
00404     lms->SPI_write(0x103, 0x0612);
00405     lms->SPI_write(0x108, 0x318C);
00406     lms->SPI_write(0x082, 0x8001);
00407     lms->SPI_write(0x200, 0x008D);
00408     lms->SPI_write(0x208, 0x01FB);
00409     lms->SPI_write(0x400, 0x8081);
00410     lms->SPI_write(0x40C, 0x01FF);
00411     lms->SPI_write(0x404, 0x0006);
00412     lms->LoadDC_REG_IQ(\textcolor{keyword}{true}, 0x3FFF, 0x3FFF);
00413     \textcolor{keywordtype}{double} srate = lms->GetSampleRate(\textcolor{keyword}{false}, LMS7002M::ChA);
00414     lms->SetFrequencySX(\textcolor{keyword}{false},450e6);
00415     \textcolor{keywordtype}{int} dec = lms->Get_SPI_Reg_bits(LMS7_HBD_OVR_RXTSP);
00416     \textcolor{keywordflow}{if} (dec > 4) dec = 0;
00417 
00418     \textcolor{keywordtype}{double} offsets[] = \{1.15/60.0, 1.1/40.0, 0.55/20.0, 0.2/10.0, 0.18/5.0\};
00419     \textcolor{keywordtype}{double} tolerance[] = \{0.9, 0.45, 0.25, 0.14, 0.06\};
00420     \textcolor{keywordtype}{double} offset = offsets[dec]*srate/1e6;
00421     std::vector<uint32\_t>  dataWr;
00422     dataWr.resize(16);
00423 
00424     dataPort->WriteRegister(0xFFFF, 1 << chipId);
00425     fpga->StopStreaming();
00426     dataPort->WriteRegister(0x0008, 0x0100);
00427     dataPort->WriteRegister(0x0007, 3);
00428     \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
00429     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 200; i++)\{
00430         lms->Modify_SPI_Reg_bits(LMS7_PD_FDIV_O_CGEN, 1);
00431         lms->Modify_SPI_Reg_bits(LMS7_PD_FDIV_O_CGEN, 0);
00432         AlignRxTSP();
00433 
00434         lms->SetFrequencySX(\textcolor{keyword}{true}, 450e6+srate/16.0);
00435         \textcolor{keywordtype}{double} offset1 = GetPhaseOffset(32);
00436         \textcolor{keywordflow}{if} (offset1 < -360)
00437             \textcolor{keywordflow}{break};
00438         lms->SetFrequencySX(\textcolor{keyword}{true}, 450e6+srate/8.0);
00439         \textcolor{keywordtype}{double} offset2 = GetPhaseOffset(64);
00440         \textcolor{keywordflow}{if} (offset2 < -360)
00441             \textcolor{keywordflow}{break};
00442         \textcolor{keywordtype}{double} diff = offset1-offset2;
00443         \textcolor{keywordflow}{if} (abs(diff-offset) < tolerance[dec])
00444         \{
00445             found = \textcolor{keyword}{true};
00446             \textcolor{keywordflow}{break};
00447         \}
00448     \}
00449     \textcolor{keywordflow}{if} (restoreValues)
00450         lms->RestoreRegisterMap(regBackup);
00451     \textcolor{keywordflow}{if} (found)
00452         AlignQuadrature(restoreValues);
00453     \textcolor{keywordflow}{else}
00454         lime::warning(\textcolor{stringliteral}{"Channel alignment failed"});
00455     lms->SPI_write(0x20, reg20);
00456 \}
00457 
00458 \textcolor{keywordtype}{void} Streamer::AlignQuadrature(\textcolor{keywordtype}{bool} restoreValues)
00459 \{
00460     \textcolor{keyword}{auto} regBackup = lms->BackupRegisterMap();
00461 
00462     lms->SPI_write(0x20, 0xFFFF);
00463     lms->SetDefaults(LMS7002M::RBB);
00464     lms->SetDefaults(LMS7002M::TBB);
00465     lms->SetDefaults(LMS7002M::TRF);
00466     lms->SPI_write(0x113, 0x0046);
00467     lms->SPI_write(0x118, 0x418C);
00468     lms->SPI_write(0x100, 0x4039);
00469     lms->SPI_write(0x101, 0x7801);
00470     lms->SPI_write(0x108, 0x318C);
00471     lms->SPI_write(0x082, 0x8001);
00472     lms->SPI_write(0x200, 0x008D);
00473     lms->SPI_write(0x208, 0x01FB);
00474     lms->SPI_write(0x400, 0x8081);
00475     lms->SPI_write(0x40C, 0x01FF);
00476     lms->SPI_write(0x404, 0x0006);
00477     lms->LoadDC_REG_IQ(\textcolor{keyword}{true}, 0x3FFF, 0x3FFF);
00478     lms->SPI_write(0x20, 0xFFFE);
00479     lms->SPI_write(0x105, 0x0006);
00480     lms->SPI_write(0x100, 0x4038);
00481     lms->SPI_write(0x113, 0x007F);
00482     lms->SPI_write(0x119, 0x529B);
00483     \textcolor{keyword}{auto} val = lms->Get_SPI_Reg_bits(LMS7_SEL_PATH_RFE, \textcolor{keyword}{true});
00484     lms->SPI_write(0x10D, val==3 ? 0x18F : val==2 ? 0x117 : 0x08F);
00485     lms->SPI_write(0x10C, val==2 ? 0x88C5 : 0x88A5);
00486     lms->SPI_write(0x20, 0xFFFD);
00487     lms->SPI_write(0x103, val==2 ? 0x612 : 0xA12);
00488     val = lms->Get_SPI_Reg_bits(LMS7_SEL_PATH_RFE, \textcolor{keyword}{true});
00489     lms->SPI_write(0x10D, val==3 ? 0x18F : val==2 ? 0x117 : 0x08F);
00490     lms->SPI_write(0x10C, val==2 ? 0x88C5 : 0x88A5);
00491     lms->SPI_write(0x119, 0x5293);
00492     \textcolor{keywordtype}{double} srate = lms->GetSampleRate(\textcolor{keyword}{false}, LMS7002M::ChA);
00493     \textcolor{keywordtype}{double} freq = lms->GetFrequencySX(\textcolor{keyword}{false});
00494 
00495     dataPort->WriteRegister(0xFFFF, 1 << chipId);
00496     fpga->StopStreaming();
00497     dataPort->WriteRegister(0x0008, 0x0100);
00498     dataPort->WriteRegister(0x0007, 3);
00499     lms->SetFrequencySX(\textcolor{keyword}{true}, freq+srate/16.0);
00500     \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
00501     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 100; i++)\{
00502 
00503         \textcolor{keywordtype}{double} offset = GetPhaseOffset(32);
00504         \textcolor{keywordflow}{if} (offset < -360)
00505             \textcolor{keywordflow}{break};
00506         \textcolor{keywordflow}{if} (fabs(offset) <= 90.0)
00507         \{
00508             found = \textcolor{keyword}{true};
00509             \textcolor{keywordflow}{break};
00510         \}
00511         RstRxIQGen();
00512     \}
00513 
00514     \textcolor{keywordflow}{if} (restoreValues)
00515         lms->RestoreRegisterMap(regBackup);
00516     \textcolor{keywordflow}{if} (!found)
00517         lime::warning(\textcolor{stringliteral}{"Channel alignment failed"});
00518 \}
00519 
00520 \textcolor{keywordtype}{int} Streamer::UpdateThreads(\textcolor{keywordtype}{bool} stopAll)
00521 \{
00522     \textcolor{keywordtype}{bool} needTx = \textcolor{keyword}{false};
00523     \textcolor{keywordtype}{bool} needRx = \textcolor{keyword}{false};
00524 
00525     \textcolor{comment}{//check which threads are needed}
00526     \textcolor{keywordflow}{if} (!stopAll)
00527     \{
00528         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &i : mRxStreams)
00529             \textcolor{keywordflow}{if}(i.used && i.IsActive())
00530             \{
00531                 needRx = \textcolor{keyword}{true};
00532                 \textcolor{keywordflow}{break};
00533             \}
00534         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &i : mTxStreams)
00535             \textcolor{keywordflow}{if}(i.used && i.IsActive())
00536             \{
00537                 needTx = \textcolor{keyword}{true};
00538                 \textcolor{keywordflow}{break};
00539             \}
00540     \}
00541 
00542     \textcolor{comment}{//stop threads if not needed}
00543     \textcolor{keywordflow}{if}((!needTx) && txThread.joinable())
00544     \{
00545         terminateTx.store(\textcolor{keyword}{true});
00546         txThread.join();
00547     \}
00548     \textcolor{keywordflow}{if}((!needRx) && rxThread.joinable())
00549     \{
00550         terminateRx.store(\textcolor{keyword}{true});
00551         rxThread.join();
00552     \}
00553 
00554     \textcolor{comment}{//configure FPGA on first start, or disable FPGA when not streaming}
00555     \textcolor{keywordflow}{if}((needTx || needRx) && (!txThread.joinable()) && (!rxThread.joinable()))
00556     \{
00557         dataPort->WriteRegister(0xFFFF, 1 << chipId);
00558         \textcolor{keywordflow}{if} (mRxStreams[0].used && mRxStreams[1].used)
00559             AlignRxRF(\textcolor{keyword}{true});
00560         \textcolor{comment}{//enable FPGA streaming}
00561         fpga->StopStreaming();
00562         fpga->ResetTimestamp();
00563         rxLastTimestamp.store(0);
00564         \textcolor{comment}{//Clear device stream buffers}
00565         dataPort->ResetStreamBuffers();
00566 
00567         \textcolor{comment}{//enable MIMO mode, 12 bit compressed values}
00568         dataLinkFormat = StreamConfig::FMT_INT12;
00569         \textcolor{comment}{//by default use 12 bit compressed, adjust link format for stream}
00570 
00571         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &i : mRxStreams)
00572             \textcolor{keywordflow}{if}(i.used && i.config.format != StreamConfig::FMT_INT12)
00573             \{
00574                 dataLinkFormat = StreamConfig::FMT_INT16;
00575                 \textcolor{keywordflow}{break};
00576             \}
00577 
00578         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &i : mTxStreams)
00579             \textcolor{keywordflow}{if}(i.used && i.config.format != StreamConfig::FMT_INT12)
00580             \{
00581                 dataLinkFormat = StreamConfig::FMT_INT16;
00582                 \textcolor{keywordflow}{break};
00583             \}
00584 
00585         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &i : mRxStreams)
00586             \textcolor{keywordflow}{if} (i.used)
00587                 i.config.linkFormat = dataLinkFormat;
00588         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &i : mTxStreams)
00589             \textcolor{keywordflow}{if} (i.used)
00590                 i.config.linkFormat = dataLinkFormat;
00591 
00592         \textcolor{keyword}{const} uint16\_t smpl\_width = dataLinkFormat == StreamConfig::FMT_INT12 ? 2 : 0;
00593         uint16\_t mode = 0x0100;
00594 
00595         \textcolor{keywordflow}{if} (lms->Get_SPI_Reg_bits(LMS7param(LML1\_SISODDR)))
00596             mode = 0x0040;
00597         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lms->Get_SPI_Reg_bits(LMS7param(LML1\_TRXIQPULSE)))
00598             mode = 0x0180;
00599 
00600         dataPort->WriteRegister(0x0008, mode | smpl\_width);
00601 
00602         \textcolor{keyword}{const} uint16\_t channelEnables = (mRxStreams[0].used||mTxStreams[0].used) + 2 * (mRxStreams[1].used
      ||mTxStreams[1].used);
00603         dataPort->WriteRegister(0x0007, channelEnables);
00604 
00605         uint32\_t reg9;
00606         dataPort->ReadRegister(0x0009, reg9);
00607         \textcolor{keyword}{const} uint32\_t addr[] = \{0x0009, 0x0009\};
00608         \textcolor{keyword}{const} uint32\_t data[] = \{reg9 | (5 << 1), reg9 & ~(5 << 1)\};
00609         fpga->StartStreaming();
00610         dataPort->WriteRegisters(addr, data, 2);
00611     \}
00612     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(not needTx and not needRx)
00613     \{
00614         \textcolor{comment}{//disable FPGA streaming}
00615         dataPort->WriteRegister(0xFFFF, 1 << chipId);
00616         fpga->StopStreaming();
00617     \}
00618 
00619     \textcolor{comment}{//FPGA should be configured and activated, start needed threads}
00620     \textcolor{keywordflow}{if}(needRx && (!rxThread.joinable()))
00621     \{
00622         terminateRx.store(\textcolor{keyword}{false});
00623         \textcolor{keyword}{auto} RxLoopFunction = std::bind(&Streamer::ReceivePacketsLoop, \textcolor{keyword}{this});
00624         rxThread = std::thread(RxLoopFunction);
00625     \}
00626     \textcolor{keywordflow}{if}(needTx && (!txThread.joinable()))
00627     \{
00628         dataPort->WriteRegister(0xFFFF, 1 << chipId);
00629         dataPort->WriteRegister(0xD, 0); \textcolor{comment}{//stop WFM}
00630         terminateTx.store(\textcolor{keyword}{false});
00631         \textcolor{keyword}{auto} TxLoopFunction = std::bind(&Streamer::TransmitPacketsLoop, \textcolor{keyword}{this});
00632         txThread = std::thread(TxLoopFunction);
00633     \}
00634     \textcolor{keywordflow}{return} 0;
00635 \}
00636 
00637 \textcolor{keywordtype}{void} Streamer::TransmitPacketsLoop()
00638 \{
00639     \textcolor{comment}{//at this point FPGA has to be already configured to output samples}
00640     \textcolor{keyword}{const} uint8\_t maxChannelCount = 2;
00641     \textcolor{keyword}{const} uint8\_t chCount = streamSize;
00642     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} packed = dataLinkFormat == StreamConfig::FMT_INT12;
00643     \textcolor{keyword}{const} \textcolor{keywordtype}{int} epIndex = chipId;
00644     \textcolor{keyword}{const} uint8\_t buffersCount = dataPort->GetBuffersCount();
00645     \textcolor{keyword}{const} uint8\_t packetsToBatch = dataPort->CheckStreamSize(rxBatchSize);
00646     \textcolor{keyword}{const} uint32\_t bufferSize = packetsToBatch*\textcolor{keyword}{sizeof}(FPGA_DataPacket);
00647     \textcolor{keyword}{const} uint32\_t popTimeout\_ms = 500;
00648 
00649     \textcolor{keyword}{const} \textcolor{keywordtype}{int} maxSamplesBatch = (packed ? samples12InPkt:samples16InPkt)/chCount;
00650     std::vector<int> handles(buffersCount, 0);
00651     std::vector<bool> bufferUsed(buffersCount, 0);
00652     std::vector<uint32\_t> bytesToSend(buffersCount, 0);
00653     std::vector<complex16\_t> samples[maxChannelCount];
00654     std::vector<char> buffers;
00655     \textcolor{keywordflow}{try}
00656     \{
00657         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<chCount; ++i)
00658             samples[i].resize(maxSamplesBatch);
00659         buffers.resize(buffersCount*bufferSize, 0);
00660     \}
00661     \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::bad\_alloc& ex) \textcolor{comment}{//not enough memory for buffers}
00662     \{
00663         \textcolor{keywordflow}{return} lime::error(\textcolor{stringliteral}{"Error allocating Tx buffers, not enough memory"});
00664     \}
00665 
00666     \textcolor{keywordtype}{long} totalBytesSent = 0;
00667     \textcolor{keyword}{auto} t1 = std::chrono::high\_resolution\_clock::now();
00668     \textcolor{keyword}{auto} t2 = t1;
00669     \textcolor{keywordtype}{bool} end\_burst = \textcolor{keyword}{false};
00670     uint8\_t bi = 0; \textcolor{comment}{//buffer index}
00671     \textcolor{keywordflow}{while} (terminateTx.load() != \textcolor{keyword}{true})
00672     \{
00673         \textcolor{keywordflow}{if} (bufferUsed[bi])
00674         \{
00675             \textcolor{keywordflow}{if} (dataPort->WaitForSending(handles[bi], 1000) == \textcolor{keyword}{true})
00676             \{
00677                 \textcolor{keywordtype}{unsigned} bytesSent = dataPort->FinishDataSending(&buffers[bi*bufferSize], bytesToSend[bi], 
      handles[bi]);
00678 
00679                 \textcolor{keywordflow}{if} (bytesSent != bytesToSend[bi])
00680                 \{
00681                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} &value : mTxStreams)
00682                         \textcolor{keywordflow}{if} (value.used && value.mActive)
00683                             value.overflow++;
00684                 \}
00685                 \textcolor{keywordflow}{else}
00686                     totalBytesSent += bytesSent;
00687                 bufferUsed[bi] = \textcolor{keyword}{false};
00688             \}
00689             \textcolor{keywordflow}{else}
00690             \{
00691                 txDataRate_Bps.store(totalBytesSent);
00692                 totalBytesSent = 0;
00693                 \textcolor{keywordflow}{continue};
00694             \}
00695         \}
00696 
00697         FPGA_DataPacket* pkt = \textcolor{keyword}{reinterpret\_cast<}FPGA_DataPacket*\textcolor{keyword}{>}(&buffers[bi*bufferSize]);
00698         \textcolor{keywordtype}{int} i=0;
00699         \textcolor{keywordflow}{do}
00700         \{
00701             \textcolor{keywordtype}{bool} has\_samples = \textcolor{keyword}{false};
00702             StreamChannel::Metadata meta = \{0, 0\};
00703             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} ch=0; ch<maxChannelCount; ++ch)
00704             \{
00705                 \textcolor{keywordflow}{if} (!mTxStreams[ch].used)
00706                     \textcolor{keywordflow}{continue};
00707                 \textcolor{keyword}{const} \textcolor{keywordtype}{int} ind = chCount == maxChannelCount ? ch : 0;
00708                 \textcolor{keywordflow}{if} (mTxStreams[ch].mActive==\textcolor{keyword}{false})
00709                 \{
00710                     memset(&samples[ind][0],0,maxSamplesBatch*\textcolor{keyword}{sizeof}(complex16_t));
00711                     \textcolor{keywordflow}{continue};
00712                 \}
00713                 \textcolor{keywordtype}{int} samplesPopped = mTxStreams[ch].Read(samples[ind].data(), maxSamplesBatch, &meta, 
      popTimeout\_ms);
00714                 \textcolor{keywordflow}{if} (samplesPopped != maxSamplesBatch)
00715                 \{
00716                     \textcolor{keywordflow}{if} ((!end\_burst) && !(meta.flags & RingFIFO::END_BURST))
00717                     \{
00718                         mTxStreams[ch].underflow++;
00719                         lime::warning(\textcolor{stringliteral}{"popping from TX, samples popped %i/%i"}, samplesPopped, 
      maxSamplesBatch);
00720                         \textcolor{keywordflow}{continue};
00721                     \}
00722                     memset(&samples[ind][samplesPopped],0,(maxSamplesBatch-samplesPopped)*\textcolor{keyword}{sizeof}(
      complex16_t));
00723                 \}
00724                 has\_samples = \textcolor{keyword}{true};
00725             \}
00726 
00727             \textcolor{keywordflow}{if} (!has\_samples)
00728                 \textcolor{keywordflow}{break};
00729 
00730             end\_burst = (meta.flags & RingFIFO::END_BURST);
00731             pkt[i].counter = meta.timestamp;
00732             pkt[i].reserved[0] = 0;
00733             \textcolor{comment}{//by default ignore timestamps}
00734             \textcolor{keyword}{const} \textcolor{keywordtype}{int} ignoreTimestamp = !(meta.flags & RingFIFO::SYNC_TIMESTAMP);
00735             pkt[i].reserved[0] |= ((int)ignoreTimestamp << 4); \textcolor{comment}{//ignore timestamp}
00736 
00737             std::vector<complex16\_t*> src(chCount);
00738             \textcolor{keywordflow}{for}(uint8\_t c=0; c<chCount; ++c)
00739                 src[c] = (samples[c].data());
00740             uint8\_t* \textcolor{keyword}{const} dataStart = (uint8\_t*)pkt[i].data;
00741             FPGA::Samples2FPGAPacketPayload(src.data(), maxSamplesBatch, chCount==2, packed, dataStart);
00742 
00743         \}\textcolor{keywordflow}{while}(++i<packetsToBatch && end\_burst == \textcolor{keyword}{false});
00744 
00745         \textcolor{keywordflow}{if}(terminateTx.load() == \textcolor{keyword}{true}) \textcolor{comment}{//early termination}
00746             \textcolor{keywordflow}{break};
00747 
00748         \textcolor{keywordflow}{if} (i)
00749         \{
00750             bytesToSend[bi] = i*\textcolor{keyword}{sizeof}(FPGA_DataPacket);
00751             handles[bi] = dataPort->BeginDataSending(&buffers[bi*bufferSize], bytesToSend[bi], epIndex);
00752             txLastTimestamp.store(pkt[i-1].counter+maxSamplesBatch-1); \textcolor{comment}{//timestamp of the last sample that
       was sent to HW}
00753             bufferUsed[bi] = \textcolor{keyword}{true};
00754             bi = (bi + 1) & (buffersCount-1);
00755         \}
00756 
00757         t2 = std::chrono::high\_resolution\_clock::now();
00758         \textcolor{keyword}{auto} timePeriod = std::chrono::duration\_cast<std::chrono::milliseconds>(
      t2 - t1).count();
00759         \textcolor{keywordflow}{if} (timePeriod >= 1000)
00760         \{
00761             \textcolor{comment}{//total number of bytes sent per second}
00762             \textcolor{keywordtype}{float} dataRate = 1000.0*totalBytesSent / timePeriod;
00763             txDataRate_Bps.store(dataRate);
00764             totalBytesSent = 0;
00765             t1 = t2;
00766 \textcolor{preprocessor}{#ifndef NDEBUG}
00767             printf(\textcolor{stringliteral}{"Tx: %.3f MB/s\(\backslash\)n"}, dataRate / 1000000.0);
00768 \textcolor{preprocessor}{#endif}
00769         \}
00770     \}
00771 
00772     \textcolor{comment}{// Wait for all the queued requests to be cancelled}
00773     dataPort->AbortSending(epIndex);
00774     txDataRate_Bps.store(0);
00775 \}
00776 
00780 \textcolor{keywordtype}{void} Streamer::ReceivePacketsLoop()
00781 \{
00782     \textcolor{comment}{//at this point FPGA has to be already configured to output samples}
00783     \textcolor{keyword}{const} uint8\_t maxChannelCount = 2;
00784     \textcolor{keyword}{const} uint8\_t chCount = streamSize;
00785     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} packed = dataLinkFormat == StreamConfig::FMT_INT12;
00786     \textcolor{keyword}{const} uint32\_t samplesInPacket = (packed  ? samples12InPkt : samples16InPkt)/chCount;
00787 
00788     \textcolor{keyword}{const} \textcolor{keywordtype}{int} epIndex = chipId;
00789     \textcolor{keyword}{const} uint8\_t buffersCount = dataPort->GetBuffersCount();
00790     \textcolor{keyword}{const} uint8\_t packetsToBatch = dataPort->CheckStreamSize(rxBatchSize);
00791     \textcolor{keyword}{const} uint32\_t bufferSize = packetsToBatch*\textcolor{keyword}{sizeof}(FPGA_DataPacket);
00792     std::vector<int> handles(buffersCount, 0);
00793     std::vector<char>buffers(buffersCount*bufferSize, 0);
00794     std::vector<StreamChannel::Frame> chFrames;
00795     \textcolor{keywordflow}{try}
00796     \{
00797         chFrames.resize(chCount);
00798     \}
00799     \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::bad\_alloc &ex)
00800     \{
00801         lime::error(\textcolor{stringliteral}{"Error allocating Rx buffers, not enough memory"});
00802         \textcolor{keywordflow}{return};
00803     \}
00804 
00805     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i<buffersCount; ++i)
00806         handles[i] = dataPort->BeginDataReading(&buffers[i*bufferSize], bufferSize, epIndex);
00807 
00808     \textcolor{keywordtype}{int} bi = 0;
00809     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} totalBytesReceived = 0; \textcolor{comment}{//for data rate calculation}
00810 
00811     \textcolor{keyword}{auto} t1 = std::chrono::high\_resolution\_clock::now();
00812     \textcolor{keyword}{auto} t2 = t1;
00813 
00814     std::mutex txFlagsLock;
00815     std::condition\_variable resetTxFlags;
00816     \textcolor{comment}{//worker thread for reseting late Tx packet flags}
00817     std::thread txReset([](IConnection* port,
00818                         std::atomic<bool> *terminate,
00819                         std::mutex *spiLock,
00820                         std::condition\_variable *doWork)
00821     \{
00822         uint32\_t reg9;
00823         port->ReadRegister(0x0009, reg9);
00824         \textcolor{keyword}{const} uint32\_t addr[] = \{0x0009, 0x0009\};
00825         \textcolor{keyword}{const} uint32\_t data[] = \{reg9 | (5 << 1), reg9 & ~(5 << 1)\};
00826         \textcolor{keywordflow}{while} (not terminate->load())
00827         \{
00828             std::unique\_lock<std::mutex> lck(*spiLock);
00829             doWork->wait(lck);
00830             port->WriteRegisters(addr, data, 2);
00831         \}
00832     \}, dataPort, &terminateRx, &txFlagsLock, &resetTxFlags);
00833 
00834     \textcolor{keywordtype}{int} resetFlagsDelay = 0;
00835     uint64\_t prevTs = 0;
00836     \textcolor{keywordflow}{while} (terminateRx.load() == \textcolor{keyword}{false})
00837     \{
00838         int32\_t bytesReceived = 0;
00839         \textcolor{keywordflow}{if}(handles[bi] >= 0)
00840         \{
00841             \textcolor{keywordflow}{if} (dataPort->WaitForReading(handles[bi], 1000) == \textcolor{keyword}{true})
00842             \{
00843                 bytesReceived = dataPort->FinishDataReading(&buffers[bi*bufferSize], bufferSize, handles[bi
      ]);
00844                 totalBytesReceived += bytesReceived;
00845                 \textcolor{keywordflow}{if} (bytesReceived != int32\_t(bufferSize)) \textcolor{comment}{//data should come in full sized packets}
00846                     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &value: mRxStreams)
00847                         \textcolor{keywordflow}{if} (value.used && value.mActive)
00848                             value.underflow++;
00849             \}
00850             \textcolor{keywordflow}{else}
00851             \{
00852                 rxDataRate_Bps.store(totalBytesReceived);
00853                 totalBytesReceived = 0;
00854                 \textcolor{keywordflow}{continue};
00855             \}
00856         \}
00857         \textcolor{keywordtype}{bool} txLate=\textcolor{keyword}{false};
00858         \textcolor{keywordflow}{for} (uint8\_t pktIndex = 0; pktIndex < bytesReceived / \textcolor{keyword}{sizeof}(
      FPGA_DataPacket); ++pktIndex)
00859         \{
00860             \textcolor{keyword}{const} FPGA_DataPacket* pkt = (FPGA_DataPacket*)&buffers[bi*bufferSize];
00861             \textcolor{keyword}{const} uint8\_t byte0 = pkt[pktIndex].reserved[0];
00862             \textcolor{keywordflow}{if} ((byte0 & (1 << 3)) != 0 && !txLate) \textcolor{comment}{//report only once per batch}
00863             \{
00864                 txLate = \textcolor{keyword}{true};
00865                 \textcolor{keywordflow}{if}(resetFlagsDelay > 0)
00866                     --resetFlagsDelay;
00867                 \textcolor{keywordflow}{else}
00868                 \{
00869                     lime::warning(\textcolor{stringliteral}{"L"});
00870                     resetTxFlags.notify\_one();
00871                     resetFlagsDelay = buffersCount;
00872                     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &value: mTxStreams)
00873                         \textcolor{keywordflow}{if} (value.used && value.mActive)
00874                             value.pktLost++;
00875                 \}
00876             \}
00877             uint8\_t* pktStart = (uint8\_t*)pkt[pktIndex].data;
00878             \textcolor{keywordflow}{if}(pkt[pktIndex].counter - prevTs != samplesInPacket && pkt[pktIndex].counter != prevTs)
00879             \{
00880                 \textcolor{keywordtype}{int} packetLoss = ((pkt[pktIndex].counter - prevTs)/samplesInPacket)-1;
00881                 \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &value: mRxStreams)
00882                     \textcolor{keywordflow}{if} (value.used && value.mActive)
00883                         value.pktLost += packetLoss;
00884             \}
00885             prevTs = pkt[pktIndex].counter;
00886             rxLastTimestamp.store(prevTs);
00887             \textcolor{comment}{//parse samples}
00888             std::vector<complex16\_t*> dest(chCount);
00889             \textcolor{keywordflow}{for}(uint8\_t c=0; c<chCount; ++c)
00890                 dest[c] = (chFrames[c].samples);
00891             \textcolor{keywordtype}{int} samplesCount = FPGA::FPGAPacketPayload2Samples(pktStart, 4080, chCount==2, packed, dest.
      data());
00892 
00893             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} ch=0; ch<maxChannelCount; ++ch)
00894             \{
00895                 \textcolor{keywordflow}{if} (mRxStreams[ch].used==\textcolor{keyword}{false} || mRxStreams[ch].mActive==\textcolor{keyword}{false})
00896                     \textcolor{keywordflow}{continue};
00897                 \textcolor{keyword}{const} \textcolor{keywordtype}{int} ind = chCount == maxChannelCount ? ch : 0;
00898                 StreamChannel::Metadata meta;
00899                 meta.timestamp = pkt[pktIndex].counter;
00900                 meta.flags = RingFIFO::OVERWRITE_OLD | RingFIFO::SYNC_TIMESTAMP;
00901                 \textcolor{keywordtype}{int} samplesPushed = mRxStreams[ch].Write((\textcolor{keyword}{const} \textcolor{keywordtype}{void}*)chFrames[ind].samples, samplesCount, 
      &meta, 100);
00902                 \textcolor{keywordflow}{if}(samplesPushed != samplesCount)
00903                     mRxStreams[ch].overflow++;
00904             \}
00905         \}
00906         \textcolor{comment}{// Re-submit this request to keep the queue full}
00907         handles[bi] = dataPort->BeginDataReading(&buffers[bi*bufferSize], bufferSize, epIndex);
00908         bi = (bi + 1) & (buffersCount-1);
00909 
00910         t2 = std::chrono::high\_resolution\_clock::now();
00911         \textcolor{keyword}{auto} timePeriod = std::chrono::duration\_cast<std::chrono::milliseconds>(
      t2 - t1).count();
00912         \textcolor{keywordflow}{if} (timePeriod >= 1000)
00913         \{
00914             t1 = t2;
00915             \textcolor{comment}{//total number of bytes sent per second}
00916             \textcolor{keywordtype}{double} dataRate = 1000.0*totalBytesReceived / timePeriod;
00917 \textcolor{preprocessor}{#ifndef NDEBUG}
00918             printf(\textcolor{stringliteral}{"Rx: %.3f MB/s\(\backslash\)n"}, dataRate / 1000000.0);
00919 \textcolor{preprocessor}{#endif}
00920             totalBytesReceived = 0;
00921             rxDataRate_Bps.store((uint32\_t)dataRate);
00922         \}
00923     \}
00924     dataPort->AbortReading(epIndex);
00925     resetTxFlags.notify\_one();
00926     txReset.join();
00927     rxDataRate_Bps.store(0);
00928 \}
00929 
00930 \}
\end{DoxyCode}
