\subsection{qa\+\_\+static\+\_\+target\+\_\+simulator\+\_\+cc.\+py}
\label{qa__static__target__simulator__cc_8py_source}\index{/home/erik/prefix/default/src/gr-\/radar-\/dev/python/qa\+\_\+static\+\_\+target\+\_\+simulator\+\_\+cc.\+py@{/home/erik/prefix/default/src/gr-\/radar-\/dev/python/qa\+\_\+static\+\_\+target\+\_\+simulator\+\_\+cc.\+py}}

\begin{DoxyCode}
00001 \textcolor{comment}{#!/usr/bin/env python}
00002 \textcolor{comment}{# -*- coding: utf-8 -*-}
00003 \textcolor{comment}{# }
00004 \textcolor{comment}{# Copyright 2014 Communications Engineering Lab, KIT.}
00005 \textcolor{comment}{# }
00006 \textcolor{comment}{# This is free software; you can redistribute it and/or modify}
00007 \textcolor{comment}{# it under the terms of the GNU General Public License as published by}
00008 \textcolor{comment}{# the Free Software Foundation; either version 3, or (at your option)}
00009 \textcolor{comment}{# any later version.}
00010 \textcolor{comment}{# }
00011 \textcolor{comment}{# This software is distributed in the hope that it will be useful,}
00012 \textcolor{comment}{# but WITHOUT ANY WARRANTY; without even the implied warranty of}
00013 \textcolor{comment}{# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
00014 \textcolor{comment}{# GNU General Public License for more details.}
00015 \textcolor{comment}{# }
00016 \textcolor{comment}{# You should have received a copy of the GNU General Public License}
00017 \textcolor{comment}{# along with this software; see the file COPYING.  If not, write to}
00018 \textcolor{comment}{# the Free Software Foundation, Inc., 51 Franklin Street,}
00019 \textcolor{comment}{# Boston, MA 02110-1301, USA.}
00020 \textcolor{comment}{# }
00021 
00022 \textcolor{keyword}{from} gnuradio \textcolor{keyword}{import} gr, gr\_unittest
00023 \textcolor{keyword}{from} gnuradio \textcolor{keyword}{import} blocks, analog, fft
00024 \textcolor{keyword}{import} radar\_swig \textcolor{keyword}{as} radar
00025 \textcolor{keyword}{import} numpy \textcolor{keyword}{as} np
00026 \textcolor{keyword}{import} numpy.fft
00027 
00028 \textcolor{keyword}{class }qa_static_target_simulator_cc (gr\_unittest.TestCase):
00029 
00030     \textcolor{keyword}{def }setUp (self):
00031         self.tb = gr.top\_block ()
00032 
00033     \textcolor{keyword}{def }tearDown (self):
00034         self.tb = \textcolor{keywordtype}{None}
00035 
00036     \textcolor{keyword}{def }test_001_t (self):
00037         \textcolor{comment}{# check doppler freq (frequency shifting)}
00038         \textcolor{comment}{# set up fg}
00039         test\_len = 1000
00040         
00041         packet\_len = test\_len
00042         samp\_rate = 2000
00043         frequency = (0,)
00044         amplitude = 1
00045         
00046         Range = (10,)
00047         velocity = (15,)
00048         rcs = (1e9,)
00049         azimuth = (0,)
00050         position\_rx = (0,)
00051         center\_freq = 1e9
00052         rndm\_phase = \textcolor{keyword}{True}
00053         self\_coupling = \textcolor{keyword}{False}
00054         self\_coupling\_db = -10;
00055         
00056         src = radar.signal\_generator\_cw\_c(packet\_len,samp\_rate,frequency,amplitude)
00057         head = blocks.head(8,test\_len)
00058         sim = radar.static\_target\_simulator\_cc(Range, velocity, rcs, azimuth, position\_rx, samp\_rate, 
      center\_freq, self\_coupling\_db, rndm\_phase, self\_coupling)
00059         mult = blocks.multiply\_cc()
00060         snk = blocks.vector\_sink\_c()
00061         
00062         self.tb.connect(src,head,sim)
00063         self.tb.connect((sim,0),(mult,0))
00064         self.tb.connect((head,0),(mult,1))
00065         self.tb.connect(mult,snk)
00066         self.tb.run ()
00067         
00068         \textcolor{comment}{# check data}
00069         data = snk.data()
00070         doppler\_freq = 2*velocity[0]*center\_freq/3e8 \textcolor{comment}{# peak estimation, calc with doppler formula}
00071         fft = numpy.fft.fft(data) \textcolor{comment}{# get fft}
00072         num = np.argmax(abs(fft)) \textcolor{comment}{# index of max sample}
00073         fft\_freq = samp\_rate*num/len(fft) \textcolor{comment}{# calc freq out of max sample index, works only for frequencies <
       samp\_rate/2!}
00074         
00075         self.assertAlmostEqual(fft\_freq,doppler\_freq,2) \textcolor{comment}{# check if peak in data is doppler peak}
00076         
00077         
00078     \textcolor{keyword}{def }test_002_t (self):
00079         \textcolor{comment}{#print "TEST2: SHIFT OF 1 SAMPLE"}
00080         \textcolor{comment}{# set up fg}
00081         test\_len = 1000
00082         packet\_len = 1000
00083         c\_light = 3e8
00084         
00085         samp\_rate = 1000
00086         freq = 5
00087         ampl = 1
00088         
00089         R = c\_light/2/samp\_rate \textcolor{comment}{# shift of 1 sample}
00090         rcs = 1e9
00091         Range = (R,)
00092         velocity = (0,) \textcolor{comment}{# no freq shift}
00093         rcs = (rcs,)
00094         azimuth = (0,)
00095         position\_rx = (0,)
00096         center\_freq = 1e9
00097         rndm\_phase = \textcolor{keyword}{False}
00098         self\_coupling = \textcolor{keyword}{False}
00099         self\_coupling\_db = 1;
00100         
00101         src = analog.sig\_source\_c(samp\_rate, analog.GR\_COS\_WAVE, freq, ampl)
00102         head = blocks.head(8,test\_len)
00103         s2ts = blocks.stream\_to\_tagged\_stream(8,1,packet\_len,\textcolor{stringliteral}{"packet\_len"})
00104         sim = radar.static\_target\_simulator\_cc(Range, velocity, rcs, azimuth, position\_rx, samp\_rate, 
      center\_freq, self\_coupling\_db, rndm\_phase, self\_coupling)
00105         snk0 = blocks.vector\_sink\_c()
00106         snk1 = blocks.vector\_sink\_c()
00107         
00108         self.tb.connect(src,head,s2ts,sim,snk0)
00109         self.tb.connect(head,snk1)
00110         self.tb.run()
00111         
00112         \textcolor{comment}{# check data with shifting of 1 sample}
00113         data\_in = snk1.data()
00114         data\_out = snk0.data()
00115         data\_out = data\_out/max(np.real(data\_out)) \textcolor{comment}{# rescale output data}
00116         self.assertComplexTuplesAlmostEqual(data\_out[1:len(data\_out)-1],data\_in[0:
      len(data\_in)-2],4)
00117         
00118     \textcolor{keyword}{def }test_003_t (self):
00119         \textcolor{comment}{#print "TEST3: AZIMUTH ESTIMATION"}
00120         \textcolor{comment}{# set up fg}
00121         packet\_len = 2**12
00122         samp\_rate = 32000
00123         center\_freq = 2.45e9
00124         freq = 0
00125         ampl = 1
00126         
00127         Range = (20,)
00128         velocity = (10,)
00129         rcs = (1e9,0)
00130         azimuth = (10,)
00131         position\_rx = (0,0.2)
00132         
00133         src = analog.sig\_source\_c(samp\_rate, analog.GR\_COS\_WAVE, freq, ampl)
00134         head = blocks.head(8,packet\_len)
00135         s2ts = blocks.stream\_to\_tagged\_stream(8,1,packet\_len,\textcolor{stringliteral}{'packet\_len'})
00136         sim = radar.static\_target\_simulator\_cc(Range, velocity, rcs, azimuth, position\_rx, samp\_rate, 
      center\_freq, -10, \textcolor{keyword}{False}, \textcolor{keyword}{False})
00137         s2v0 = blocks.stream\_to\_vector(8,packet\_len)
00138         fft0 = fft.fft\_vcc(packet\_len,\textcolor{keyword}{True},())
00139         v2s0 = blocks.vector\_to\_stream(8,packet\_len)
00140         snk0 = blocks.vector\_sink\_c()
00141         s2v1 = blocks.stream\_to\_vector(8,packet\_len)
00142         fft1 = fft.fft\_vcc(packet\_len,\textcolor{keyword}{True},())
00143         v2s1 = blocks.vector\_to\_stream(8,packet\_len)
00144         snk1 = blocks.vector\_sink\_c()
00145         
00146         mult = blocks.multiply\_conjugate\_cc(packet\_len)
00147         v2s2 = blocks.vector\_to\_stream(8,packet\_len)
00148         snk2 = blocks.vector\_sink\_c()
00149         
00150         
00151         self.tb.connect(src,head,s2ts,sim)
00152         self.tb.connect((sim,0),(s2v0,0))
00153         self.tb.connect(s2v0,fft0,v2s0,snk0)
00154         self.tb.connect((sim,1),(s2v1,0))
00155         self.tb.connect(s2v1,fft1,v2s1,snk1)
00156         
00157         self.tb.connect((fft0,0),(mult,1))
00158         self.tb.connect((fft1,0),(mult,0))
00159         self.tb.connect(mult,v2s2,snk2)
00160         
00161         self.tb.run()
00162         
00163         \textcolor{comment}{# check ffts data0 und data1 on peak}
00164         data0 = snk0.data()
00165         data1 = snk1.data()
00166         
00167         data0\_abs = [0]*len(data0)
00168         data1\_abs = [0]*len(data1)
00169         \textcolor{keywordflow}{for} k \textcolor{keywordflow}{in} range(len(data0)):
00170             data0\_abs[k] = abs(data0[k])
00171             data1\_abs[k] = abs(data1[k])
00172         
00173         num0 = np.argmax(data0\_abs) \textcolor{comment}{# index of max sample (data)}
00174         num1 = np.argmax(data1\_abs) \textcolor{comment}{# index of max sample (data)}
00175         \textcolor{comment}{#print "NUM0:", num0, "FREQ:", num0*samp\_rate/packet\_len, "VELOCITY:",
       num0*samp\_rate/packet\_len*3e8/2/center\_freq, "PHI:", np.angle(data0[num0])}
00176         \textcolor{comment}{#print "NUM1:", num1, "FREQ:", num1*samp\_rate/packet\_len, "VELOCITY:",
       num1*samp\_rate/packet\_len*3e8/2/center\_freq, "PHI:", np.angle(data1[num1])}
00177         
00178         \textcolor{comment}{# check fft data2 on peak}
00179         data2 = snk2.data()
00180         data2\_abs = [0]*len(data2)
00181         \textcolor{keywordflow}{for} k \textcolor{keywordflow}{in} range(len(data0)):
00182             data2\_abs[k] = abs(data2[k])
00183         num2 = np.argmax(data2\_abs) \textcolor{comment}{# index of max sample (data)}
00184         \textcolor{comment}{#print "NUM2:", num2, "FREQ:", num2*samp\_rate/packet\_len, "VELOCITY:",
       num2*samp\_rate/packet\_len*3e8/2/center\_freq, "PHI:", np.angle(data2[num2])}
00185         
00186         \textcolor{comment}{# assert phases of rx streams of angle(data1)-angle(data0) and angle(data2)}
00187         self.assertAlmostEqual(np.angle(data1[num1])-np.angle(data0[num0]),np.angle(data2[num2]),4)
00188         
00189         \textcolor{comment}{# assert azimuth}
00190         angle = np.arcsin(np.angle(data2[num2])*3e8/center\_freq/2/np.pi/0.2)/2/np.pi*360;
00191         self.assertAlmostEqual(angle/azimuth[0],1,0)
00192 
00193 \textcolor{keywordflow}{if} \_\_name\_\_ == \textcolor{stringliteral}{'\_\_main\_\_'}:
00194     gr\_unittest.run(qa\_static\_target\_simulator\_cc)\textcolor{comment}{#, "qa\_static\_target\_simulator\_cc.xml")}
\end{DoxyCode}
