\subsection{os\+\_\+cfar\+\_\+c\+\_\+impl.\+cc}
\label{os__cfar__c__impl_8cc_source}\index{/home/erik/prefix/default/src/gr-\/radar-\/dev/lib/os\+\_\+cfar\+\_\+c\+\_\+impl.\+cc@{/home/erik/prefix/default/src/gr-\/radar-\/dev/lib/os\+\_\+cfar\+\_\+c\+\_\+impl.\+cc}}

\begin{DoxyCode}
00001 \textcolor{comment}{//* -*- c++ -*- */}
00002 \textcolor{comment}{/* }
00003 \textcolor{comment}{ * Copyright 2014 Communications Engineering Lab, KIT.}
00004 \textcolor{comment}{ * }
00005 \textcolor{comment}{ * This is free software; you can redistribute it and/or modify}
00006 \textcolor{comment}{ * it under the terms of the GNU General Public License as published by}
00007 \textcolor{comment}{ * the Free Software Foundation; either version 3, or (at your option)}
00008 \textcolor{comment}{ * any later version.}
00009 \textcolor{comment}{ * }
00010 \textcolor{comment}{ * This software is distributed in the hope that it will be useful,}
00011 \textcolor{comment}{ * but WITHOUT ANY WARRANTY; without even the implied warranty of}
00012 \textcolor{comment}{ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
00013 \textcolor{comment}{ * GNU General Public License for more details.}
00014 \textcolor{comment}{ * }
00015 \textcolor{comment}{ * You should have received a copy of the GNU General Public License}
00016 \textcolor{comment}{ * along with this software; see the file COPYING.  If not, write to}
00017 \textcolor{comment}{ * the Free Software Foundation, Inc., 51 Franklin Street,}
00018 \textcolor{comment}{ * Boston, MA 02110-1301, USA.}
00019 \textcolor{comment}{ */}
00020  
00021 \textcolor{preprocessor}{#ifdef HAVE\_CONFIG\_H}
00022 \textcolor{preprocessor}{#include "config.h"}
00023 \textcolor{preprocessor}{#endif}
00024 
00025 \textcolor{preprocessor}{#include <gnuradio/io\_signature.h>}
00026 \textcolor{preprocessor}{#include "os_cfar_c_impl.h"}
00027 
00028 \textcolor{keyword}{namespace }gr \{
00029   \textcolor{keyword}{namespace }radar \{
00030 
00031     os_cfar_c::sptr
00032     os_cfar_c::make(\textcolor{keywordtype}{int} samp_rate, \textcolor{keywordtype}{int} samp\_compare, \textcolor{keywordtype}{int} samp\_protect, \textcolor{keywordtype}{float} rel\_threshold, \textcolor{keywordtype}{float} 
      mult\_threshold, \textcolor{keywordtype}{bool} merge\_consecutive, \textcolor{keyword}{const} std::string& len\_key)
00033     \{
00034       \textcolor{keywordflow}{return} gnuradio::get\_initial\_sptr
00035         (\textcolor{keyword}{new} os_cfar_c_impl(samp\_rate, samp\_compare, samp\_protect, rel\_threshold, mult\_threshold, 
      merge\_consecutive, len\_key));
00036     \}
00037 
00038     \textcolor{comment}{/*}
00039 \textcolor{comment}{     * The private constructor}
00040 \textcolor{comment}{     */}
00041     os_cfar_c_impl::os_cfar_c_impl(\textcolor{keywordtype}{int} samp_rate, \textcolor{keywordtype}{int} samp\_compare, \textcolor{keywordtype}{int} samp\_protect, \textcolor{keywordtype}{float} rel\_threshold, \textcolor{keywordtype}{
      float} mult\_threshold, \textcolor{keywordtype}{bool} merge\_consecutive, \textcolor{keyword}{const} std::string& len\_key)
00042       : gr::tagged\_stream\_block(\textcolor{stringliteral}{"os\_cfar\_c"},
00043               gr::io\_signature::make(1, 1, sizeof(gr\_complex)),
00044               gr::io\_signature::make(0, 0, 0), len\_key)
00045     \{
00046         d_samp_rate = samp_rate;
00047         d_samp_compare = samp\_compare;
00048         d_samp_protect = samp\_protect;
00049         d_rel_threshold = rel\_threshold;
00050         d_mult_threshold = mult\_threshold;
00051         d_consecutive = \textcolor{keyword}{false};
00052         d_merge_consecutive = merge\_consecutive;
00053         
00054         \textcolor{comment}{// Register message port}
00055         d_port_id = pmt::mp(\textcolor{stringliteral}{"Msg out"});
00056         message\_port\_register\_out(d_port_id);
00057     \}
00058     
00059     \textcolor{keywordtype}{void} os_cfar_c_impl::set_rel_threshold(\textcolor{keywordtype}{float} inp)\{ d_rel_threshold = inp; \}
00060     \textcolor{keywordtype}{void} os_cfar_c_impl::set_mult_threshold(\textcolor{keywordtype}{float} inp)\{ d_mult_threshold = inp; \}
00061     \textcolor{keywordtype}{void} os_cfar_c_impl::set_samp_compare(\textcolor{keywordtype}{int} inp)\{ d_samp_compare = inp; \}
00062     \textcolor{keywordtype}{void} os_cfar_c_impl::set_samp_protect(\textcolor{keywordtype}{int} inp)\{ d_samp_protect = inp; \}
00063 
00064     \textcolor{comment}{/*}
00065 \textcolor{comment}{     * Our virtual destructor.}
00066 \textcolor{comment}{     */}
00067     os_cfar_c_impl::~os_cfar_c_impl()
00068     \{
00069     \}
00070 
00071     \textcolor{keywordtype}{int}
00072     os_cfar_c_impl::calculate_output_stream_length(\textcolor{keyword}{const} gr\_vector\_int &ninput\_items)
00073     \{
00074       \textcolor{keywordtype}{int} noutput\_items = 0;
00075       \textcolor{keywordflow}{return} noutput\_items ;
00076     \}
00077 
00078     \textcolor{keywordtype}{int}
00079     os_cfar_c_impl::work (\textcolor{keywordtype}{int} noutput\_items,
00080                        gr\_vector\_int &ninput\_items,
00081                        gr\_vector\_const\_void\_star &input\_items,
00082                        gr\_vector\_void\_star &output\_items)
00083     \{
00084         \textcolor{keyword}{const} gr\_complex *in = (\textcolor{keyword}{const} gr\_complex *) input\_items[0];
00085         
00086         \textcolor{comment}{// OS-CFAR detection}
00087         d_freq.clear();
00088         d_pks.clear();
00089         d_angle.clear();
00090         
00091         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<ninput\_items[0]; k++)\{ \textcolor{comment}{// go through input}
00092             d_hold_samp.clear();
00093             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} l=1; l<d_samp_compare+1; l++)\{ \textcolor{comment}{// go through samples to compare, care: num of
       samp\_compare is doubled! redef if too confusing}
00094                 \textcolor{keywordflow}{if}(k-l-d_samp_protect<0)\{ \textcolor{comment}{// push-back zeros for underflows}
00095                     d_hold_samp.push\_back(0);
00096                 \}
00097                 \textcolor{keywordflow}{else}\{ \textcolor{comment}{// push back abs-square}
00098                     d_hold_samp.push\_back(std::pow(std::abs(in[k-l-
      d_samp_protect]),2));
00099                 \}
00100                 \textcolor{keywordflow}{if}(k+l+d_samp_protect>=ninput\_items[0])\{ \textcolor{comment}{// push-back zeros for overflows}
00101                     d_hold_samp.push\_back(0);
00102                 \}
00103                 \textcolor{keywordflow}{else}\{ \textcolor{comment}{// push back abs-square}
00104                     d_hold_samp.push\_back(std::pow(std::abs(in[k+l+
      d_samp_protect]),2));
00105                 \}
00106             \}
00107             std::sort(d_hold_samp.begin(),d_hold_samp.end()); \textcolor{comment}{// sort sample vector}
00108             
00109             \textcolor{keywordflow}{if}(std::pow(std::abs(in[k]),2)>d_hold_samp[(int)((2*d\_samp\_compare-1)*
      d_rel_threshold)]*d_mult_threshold)\{ \textcolor{comment}{// check if in[k] is over dynamic threshold multiplied with
       mult\_threshold}
00110                 \textcolor{comment}{// Add peaks, frequencies and angle}
00111                 \textcolor{keywordflow}{if}(k<=ninput\_items[0]/2)\{
00112                     d_freq.push\_back(k*(d_samp_rate/(\textcolor{keywordtype}{float})ninput\_items[0])); \textcolor{comment}{// add frequency to message
       vector d\_freq}
00113                 \}
00114                 \textcolor{keywordflow}{else}\{
00115                     d_freq.push\_back(-(\textcolor{keywordtype}{float})d_samp_rate+k*(d_samp_rate/(\textcolor{keywordtype}{float})ninput\_items[0]));
00116                 \}
00117                 d_pks.push\_back(pow(abs(in[k]),2)); \textcolor{comment}{// add abs-square to message vector d\_pks}
00118                 d_angle.push\_back(std::arg(in[k])); \textcolor{comment}{// add angle to message vector d\_angle}
00119                 
00120                 \textcolor{comment}{// Merge consecutive peaks}
00121                 \textcolor{keywordflow}{if}( (d_merge_consecutive && d_consecutive) && d_freq.size()>1)\{
00122                     \textcolor{keywordflow}{if}(d_pks[d_pks.size()-2]<d_pks[d_pks.size()-1])\{ \textcolor{comment}{// if last peak is lower, remove last
       one}
00123                         d_pks.erase(d_pks.end()-2); \textcolor{comment}{// vec.end() points past the end!}
00124                         d_freq.erase(d_freq.end()-2);
00125                         d_angle.erase(d_angle.end()-2);
00126                     \}
00127                     \textcolor{keywordflow}{else}\{ \textcolor{comment}{// if last peak is higher, remove actual one}
00128                         d_pks.erase(d_pks.end()-1);
00129                         d_freq.erase(d_freq.end()-1);
00130                         d_angle.erase(d_angle.end()-1);
00131                     \}
00132                 \}
00133                 
00134                 d_consecutive = \textcolor{keyword}{true}; \textcolor{comment}{// tag next loop cycle with check for merging peaks}
00135             \}
00136             \textcolor{keywordflow}{else}\{
00137                 d_consecutive = \textcolor{keyword}{false}; \textcolor{comment}{// release consecutive peaks merger if no peak is detected}
00138             \}
00139             
00140         \}
00141         
00142         \textcolor{comment}{// get rx\_time tag}
00143         get\_tags\_in\_range(d_tags,0,nitems\_read(0),nitems\_read(0)+1,pmt::string\_to\_symbol(\textcolor{stringliteral}{"rx\_time"}));
00144         
00145         \textcolor{comment}{// setup msg pmt}
00146         \textcolor{keywordflow}{if}(d_tags.size()>0) d_ptimestamp = pmt::list2(pmt::string\_to\_symbol(\textcolor{stringliteral}{"rx\_time"}),
      d_tags[0].value);
00147         \textcolor{keywordflow}{else} d_ptimestamp = pmt::list2(pmt::string\_to\_symbol(\textcolor{stringliteral}{"rx\_time"}),pmt::make\_tuple(pmt::from\_uint64(0)
      ,pmt::from\_double(-1))); \textcolor{comment}{// if no timetag is found, set to 0 and frac\_sec to -1}
00148         d_pfreq = pmt::list2(pmt::string\_to\_symbol(\textcolor{stringliteral}{"frequency"}),pmt::init\_f32vector(
      d_freq.size(),d_freq));
00149         d_ppks = pmt::list2(pmt::string\_to\_symbol(\textcolor{stringliteral}{"power"}),pmt::init\_f32vector(
      d_pks.size(),d_pks));
00150         d_pangle = pmt::list2(pmt::string\_to\_symbol(\textcolor{stringliteral}{"phase"}),pmt::init\_f32vector(
      d_angle.size(),d_angle));
00151         d_value = pmt::list4(d_ptimestamp,d_pfreq,d_ppks,d_pangle);
00152         
00153         \textcolor{comment}{// publish message}
00154         message\_port\_pub(d_port_id,d_value);
00155 
00156         \textcolor{comment}{// Tell runtime system how many output items we produced.}
00157         \textcolor{keywordflow}{return} 0;
00158     \}
00159 
00160   \} \textcolor{comment}{/* namespace radar */}
00161 \} \textcolor{comment}{/* namespace gr */}
00162 
\end{DoxyCode}
