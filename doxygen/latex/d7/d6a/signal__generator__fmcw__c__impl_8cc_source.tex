\subsection{signal\+\_\+generator\+\_\+fmcw\+\_\+c\+\_\+impl.\+cc}
\label{signal__generator__fmcw__c__impl_8cc_source}\index{/home/erik/prefix/default/src/gr-\/radar-\/dev/lib/signal\+\_\+generator\+\_\+fmcw\+\_\+c\+\_\+impl.\+cc@{/home/erik/prefix/default/src/gr-\/radar-\/dev/lib/signal\+\_\+generator\+\_\+fmcw\+\_\+c\+\_\+impl.\+cc}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* -*- c++ -*- */}
00002 \textcolor{comment}{/*}
00003 \textcolor{comment}{ * Copyright 2014 Communications Engineering Lab, KIT.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * This is free software; you can redistribute it and/or modify}
00006 \textcolor{comment}{ * it under the terms of the GNU General Public License as published by}
00007 \textcolor{comment}{ * the Free Software Foundation; either version 3, or (at your option)}
00008 \textcolor{comment}{ * any later version.}
00009 \textcolor{comment}{ *}
00010 \textcolor{comment}{ * This software is distributed in the hope that it will be useful,}
00011 \textcolor{comment}{ * but WITHOUT ANY WARRANTY; without even the implied warranty of}
00012 \textcolor{comment}{ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
00013 \textcolor{comment}{ * GNU General Public License for more details.}
00014 \textcolor{comment}{ *}
00015 \textcolor{comment}{ * You should have received a copy of the GNU General Public License}
00016 \textcolor{comment}{ * along with this software; see the file COPYING.  If not, write to}
00017 \textcolor{comment}{ * the Free Software Foundation, Inc., 51 Franklin Street,}
00018 \textcolor{comment}{ * Boston, MA 02110-1301, USA.}
00019 \textcolor{comment}{ */}
00020 
00021 \textcolor{preprocessor}{#ifdef HAVE\_CONFIG\_H}
00022 \textcolor{preprocessor}{#include "config.h"}
00023 \textcolor{preprocessor}{#endif}
00024 
00025 \textcolor{preprocessor}{#include <gnuradio/io\_signature.h>}
00026 \textcolor{preprocessor}{#include "signal_generator_fmcw_c_impl.h"}
00027 
00028 \textcolor{keyword}{namespace }gr \{
00029   \textcolor{keyword}{namespace }radar \{
00030 
00031     signal_generator_fmcw_c::sptr
00032     signal_generator_fmcw_c::make(
00033             \textcolor{keyword}{const} \textcolor{keywordtype}{int} samp_rate,
00034             \textcolor{keyword}{const} \textcolor{keywordtype}{int} packet\_len,
00035             \textcolor{keywordtype}{int} samp_up,
00036             \textcolor{keywordtype}{int} samp\_up\_hold,
00037             \textcolor{keywordtype}{int} samp_down,
00038             \textcolor{keywordtype}{int} samp\_down\_hold,
00039             \textcolor{keywordtype}{int} samp_cw,
00040             \textcolor{keywordtype}{int} samp\_dead,
00041             \textcolor{keyword}{const} \textcolor{keywordtype}{float} freq_cw,
00042             \textcolor{keyword}{const} \textcolor{keywordtype}{float} freq\_sweep,
00043             \textcolor{keyword}{const} \textcolor{keywordtype}{float} amplitude,
00044             \textcolor{keyword}{const} std::string& len\_key,
00045             \textcolor{keyword}{const} std::string& chirp\_len\_key,
00046             \textcolor{keyword}{const} std::string& total\_len\_key
00047     ) \{
00048       \textcolor{keywordflow}{return} gnuradio::get\_initial\_sptr(\textcolor{keyword}{new} signal_generator_fmcw_c_impl(
00049           samp\_rate,
00050           packet\_len,
00051           samp\_up,
00052           samp\_up\_hold,
00053           samp\_down,
00054           samp\_down\_hold,
00055           samp\_cw,
00056           samp\_dead,
00057           freq\_cw,
00058           freq\_sweep,
00059           amplitude,
00060           len\_key,
00061           chirp\_len\_key,
00062           total\_len\_key
00063       ));
00064     \}
00065 
00066     signal_generator_fmcw_c_impl::signal_generator_fmcw_c_impl(
00067             \textcolor{keyword}{const} \textcolor{keywordtype}{int} samp_rate,
00068             \textcolor{keyword}{const} \textcolor{keywordtype}{int} packet\_len,
00069             \textcolor{keywordtype}{int} samp_up,
00070             \textcolor{keywordtype}{int} samp\_up\_hold,
00071             \textcolor{keywordtype}{int} samp_down,
00072             \textcolor{keywordtype}{int} samp\_down\_hold,
00073             \textcolor{keywordtype}{int} samp_cw,
00074             \textcolor{keywordtype}{int} samp\_dead,
00075             \textcolor{keywordtype}{float} freq_cw,
00076             \textcolor{keyword}{const} \textcolor{keywordtype}{float} freq\_sweep,
00077             \textcolor{keyword}{const} \textcolor{keywordtype}{float} amplitude,
00078             \textcolor{keyword}{const} std::string& len\_key,
00079             \textcolor{keyword}{const} std::string& chirp\_len\_key,
00080             \textcolor{keyword}{const} std::string& total\_len\_key)
00081       : gr::sync\_block(\textcolor{stringliteral}{"signal\_generator\_fmcw\_c"},
00082               gr::io\_signature::make(0, 0, 0),
00083               gr::io\_signature::make(1, 1, sizeof(gr\_complex)))
00084       , d\_samp\_rate(samp\_rate)
00085       , d\_samp\_up(samp\_up)
00086       , d\_samp\_up\_hold(samp\_up\_hold)
00087       , d\_samp\_down(samp\_down)
00088       , d\_samp\_down\_hold(samp\_down\_hold)
00089       , d\_samp\_cw(samp\_cw)
00090       , d\_samp\_dead(samp\_dead)
00091       , d\_freq\_cw(freq\_cw)
00092       , d\_freq\_sweep(freq\_sweep)
00093       , d\_amplitude(amplitude)
00094 
00095       , d\_packet\_len(packet\_len)
00096       , d\_key\_len(pmt::string\_to\_symbol(len\_key))
00097       , d\_value\_len(pmt::from\_long(d\_packet\_len))
00098 
00099       , d\_chirp\_len(samp\_cw+samp\_up+samp\_up\_hold+samp\_down+samp\_down\_hold)
00100       , d\_total\_len(d\_chirp\_len + samp\_dead)
00101 
00102       , d\_key\_chirp\_len(pmt::string\_to\_symbol(chirp\_len\_key))
00103       , d\_value\_chirp\_len(pmt::from\_long(d\_chirp\_len))
00104 
00105       , d\_key\_total\_len(pmt::string\_to\_symbol(total\_len\_key))
00106       , d\_value\_total\_len(pmt::from\_long(d\_total\_len))
00107 
00108       , d\_key\_deadtime(pmt::string\_to\_symbol(\textcolor{stringliteral}{"Deadtime"}))
00109       , d\_value\_deadtime(pmt::from\_long(samp\_dead))
00110 
00111       , d\_srcid(pmt::string\_to\_symbol(\textcolor{stringliteral}{"sig\_gen\_fmcw"}))
00112 
00113       , d\_wv\_counter(0)
00114       , d\_waveform(d\_total\_len, freq\_cw)
00115       , d\_waveform\_amp(d\_total\_len,d\_amplitude)
00116     \{
00117       set_d_samp_dead(d_samp_dead);\textcolor{comment}{//reset dead samples to allign total samples}
00118     \}
00119 
00120     signal_generator_fmcw_c_impl::~signal_generator_fmcw_c_impl()
00121     \{
00122     \}
00123 
00124     \textcolor{comment}{//Auxiliary method: Set Members (perform calculations if necessary)}
00125     \textcolor{keywordtype}{void}
00126     signal_generator_fmcw_c_impl::set_d_chirp_len(\textcolor{keywordtype}{int} chirp\_length)
00127     \{d_chirp_len = chirp\_length;\}
00128 
00129     \textcolor{keywordtype}{void}
00130     signal_generator_fmcw_c_impl::set_d_total_len(\textcolor{keywordtype}{int} total\_length)
00131     \{
00132       d_total_len = total\_length;
00133       d_value_total_len = pmt::from\_long(total\_length);
00134     \}
00135 
00136     \textcolor{keywordtype}{void}
00137     signal_generator_fmcw_c_impl::set_waveform()
00138     \{
00139 
00140       d_waveform.assign(d_total_len,d_freq_cw);
00141       d_waveform_amp.assign(d_total_len,d_amplitude);
00142       \textcolor{comment}{// Setup waveform vector: Contains cw, up-chirp (hold), down-chirp (hold).}
00143       \textcolor{comment}{// CW is already set above. Note this vector contains the phase increment of}
00144       \textcolor{comment}{// the waveform, not the IQ samples itself.}
00145       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<d_samp_up; k++) \{
00146         d_waveform[k+d_samp_cw] =
00147           d_freq_cw + (d_freq_sweep/(float)d\_samp\_up) * k;
00148       \}
00149       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<d_samp_up_hold; k++) \{
00150         d_waveform[k+d_samp_cw+d_samp_up] =
00151           d_freq_cw + d_freq_sweep;
00152       \}
00153       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<d_samp_down; k++) \{
00154         d_waveform[k+d_samp_cw+d\_samp\_up+d_samp_up_hold] =
00155           d_freq_cw + d_freq_sweep - (d_freq_sweep/(float)d\_samp\_down) * k;
00156       \}
00157       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<d_samp_down_hold; k++) \{
00158       d_waveform[k+d_samp_cw+d\_samp\_up+d\_samp\_up\_hold+d_samp_down] =
00159           d_freq_cw;
00160       \}
00161       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<d_samp_dead; k++) \{
00162       d_waveform_amp[k+d_samp_cw+d\_samp\_up+d\_samp\_up\_hold+d\_samp\_down+
      d_samp_down_hold] =
00163           0;
00164       \}
00165 
00166       d_wv_counter = 0;
00167       d_counter_deadtime = 0;
00168     \}
00169 
00170     \textcolor{keywordtype}{void}  signal_generator_fmcw_c_impl::set_d_samp_dead(\textcolor{keywordtype}{int} dead\_samples)
00171     \{
00172       \textcolor{comment}{//d\_samp\_dead = dead\_samples;}
00173       set_d_samp_dead_round(dead\_samples);
00174       set_waveform();
00175     \}
00176 
00177     \textcolor{keywordtype}{void}
00178     signal_generator_fmcw_c_impl::set_d_samp_dead_round(\textcolor{keywordtype}{int} dead\_samples)
00179     \{
00180       \textcolor{comment}{//round up to nearest packet len: update d\_samp\_dead and d\_total\_len}
00181       \textcolor{keywordtype}{int} packet\_modulo = (d_chirp_len + dead\_samples) % d_packet_len;
00182       d_samp_dead = (dead\_samples + d_packet_len) - packet\_modulo;
00183       d_total_len = d_chirp_len + d_samp_dead;
00184 
00185       d_value_deadtime = pmt::from\_long(d\_samp\_dead);
00186       d_value_total_len = pmt::from\_long(d_total_len);
00187     \}
00188 
00189     \textcolor{keywordtype}{void}
00190     signal_generator_fmcw_c_impl::set_chirp(\textcolor{keywordtype}{int} up\_samples, \textcolor{keywordtype}{int} up\_hold\_samples,
00191                                             \textcolor{keywordtype}{int} down\_samples, \textcolor{keywordtype}{int} down\_hold\_samples,
00192                                             \textcolor{keywordtype}{int} cw\_samples)
00193     \{
00194       \textcolor{comment}{//set members: all chirp related}
00195       d_samp_up = up\_samples;
00196       d_samp_up_hold = up\_hold\_samples;
00197       d_samp_down = down\_samples;
00198       d_samp_down_hold = down\_hold\_samples;
00199       d_samp_cw = cw\_samples;
00200       d_chirp_len = up\_samples+up\_hold\_samples+down\_samples+down\_hold\_samples+cw\_samples;
00201 
00202       d_value_chirp_len = pmt::from\_long(d_chirp_len);
00203 
00204       set_d_samp_dead(d_samp_dead);\textcolor{comment}{//must update deadsamples}
00205     \}
00206 
00207     \textcolor{comment}{// Work Function}
00208     \textcolor{keywordtype}{int}
00209     signal_generator_fmcw_c_impl::work(
00210         \textcolor{keywordtype}{int} noutput\_items,
00211         gr\_vector\_const\_void\_star &input\_items,
00212         gr\_vector\_void\_star &output\_items
00213     ) \{
00214       gr\_complex *out = (gr\_complex *) output\_items[0];
00215       \textcolor{comment}{// Integrate phase for iq signal}
00216       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<noutput\_items; i++) \{
00217 
00218         \textcolor{keywordflow}{if} (((nitems\_written(0)+i) % d_total_len) == (d_chirp_len)) \{
00219           d_counter_deadtime = 1;
00220         \}
00221 
00222         \textcolor{comment}{// Set tag on every packet\_len-th item}
00223 
00224         \textcolor{comment}{// Set tag on every chirp\_len-th item}
00225         \textcolor{keywordflow}{if} ((nitems\_written(0)+i) % d\_total\_len == 0) \{
00226           add\_item\_tag(0, nitems\_written(0)+i, d_key_chirp_len, 
      d_value_chirp_len, d_srcid);
00227           add\_item\_tag(0, nitems\_written(0)+i, d_key_total_len, 
      d_value_total_len, d_srcid);
00228           d_counter_deadtime = 0;
00229           d_wv_counter = 0;
00230         \}
00231 
00232 
00233         \textcolor{keywordflow}{if} ((nitems\_written(0)+i) % d_packet_len == 0) \{
00234           add\_item\_tag(0, nitems\_written(0)+i, d_key_len, d_value_len, d_srcid);
00235           \textcolor{keywordflow}{if}(d_counter_deadtime)
00236             add\_item\_tag(0, nitems\_written(0)+i, d_key_deadtime, 
      d_value_deadtime, d_srcid);
00237           \textcolor{comment}{//d\_wv\_counter = 0;}
00238         \}
00239 
00240 
00241 
00242 
00243 
00244         \textcolor{comment}{// Write sample}
00245         *out++ = d_amp*exp(d_phase);
00246 
00247         \textcolor{comment}{//if((nitems\_written(0)) % d\_samp\_up)}
00248         d_phase = 1j*std::fmod(
00249             imag(d_phase)+2*M\_PI*d_waveform[d_wv_counter]/(\textcolor{keywordtype}{float})d_samp_rate,
00250             2*M\_PI
00251         );
00252         d_amp = d_waveform_amp[d_wv_counter];
00253         d_wv_counter++;
00254       \}
00255 
00256       \textcolor{comment}{// Tell runtime system how many output items we produced.}
00257       \textcolor{keywordflow}{return} noutput\_items;
00258     \}
00259 
00260   \} \textcolor{comment}{/* namespace radar */}
00261 \} \textcolor{comment}{/* namespace gr */}
\end{DoxyCode}
