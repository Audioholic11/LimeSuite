\subsection{msg\+\_\+manipulator\+\_\+impl.\+cc}
\label{msg__manipulator__impl_8cc_source}\index{/home/erik/prefix/default/src/gr-\/radar-\/dev/lib/msg\+\_\+manipulator\+\_\+impl.\+cc@{/home/erik/prefix/default/src/gr-\/radar-\/dev/lib/msg\+\_\+manipulator\+\_\+impl.\+cc}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* -*- c++ -*- */}
00002 \textcolor{comment}{/* }
00003 \textcolor{comment}{ * Copyright 2014 Communications Engineering Lab, KIT.}
00004 \textcolor{comment}{ * }
00005 \textcolor{comment}{ * This is free software; you can redistribute it and/or modify}
00006 \textcolor{comment}{ * it under the terms of the GNU General Public License as published by}
00007 \textcolor{comment}{ * the Free Software Foundation; either version 3, or (at your option)}
00008 \textcolor{comment}{ * any later version.}
00009 \textcolor{comment}{ * }
00010 \textcolor{comment}{ * This software is distributed in the hope that it will be useful,}
00011 \textcolor{comment}{ * but WITHOUT ANY WARRANTY; without even the implied warranty of}
00012 \textcolor{comment}{ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
00013 \textcolor{comment}{ * GNU General Public License for more details.}
00014 \textcolor{comment}{ * }
00015 \textcolor{comment}{ * You should have received a copy of the GNU General Public License}
00016 \textcolor{comment}{ * along with this software; see the file COPYING.  If not, write to}
00017 \textcolor{comment}{ * the Free Software Foundation, Inc., 51 Franklin Street,}
00018 \textcolor{comment}{ * Boston, MA 02110-1301, USA.}
00019 \textcolor{comment}{ */}
00020 
00021 \textcolor{preprocessor}{#ifdef HAVE\_CONFIG\_H}
00022 \textcolor{preprocessor}{#include "config.h"}
00023 \textcolor{preprocessor}{#endif}
00024 
00025 \textcolor{preprocessor}{#include <gnuradio/io\_signature.h>}
00026 \textcolor{preprocessor}{#include "msg_manipulator_impl.h"}
00027 
00028 \textcolor{keyword}{namespace }gr \{
00029   \textcolor{keyword}{namespace }radar \{
00030 
00031     msg_manipulator::sptr
00032     msg_manipulator::make(std::vector<std::string> symbols, std::vector<float> const\_add, 
      std::vector<float> const\_mult)
00033     \{
00034       \textcolor{keywordflow}{return} gnuradio::get\_initial\_sptr
00035         (\textcolor{keyword}{new} msg_manipulator_impl(symbols, const\_add, const\_mult));
00036     \}
00037 
00038     \textcolor{comment}{/*}
00039 \textcolor{comment}{     * The private constructor}
00040 \textcolor{comment}{     */}
00041     msg_manipulator_impl::msg_manipulator_impl(std::vector<std::string> symbols, std::vector<float> 
      const\_add, std::vector<float> const\_mult)
00042       : gr::block(\textcolor{stringliteral}{"msg\_manipulator"},
00043               gr::io\_signature::make(0,0,0),
00044               gr::io\_signature::make(0,0,0))
00045     \{
00046         d_symbols = symbols;
00047         d_const_add = const\_add;
00048         d_const_mult = const\_mult;
00049         
00050         \textcolor{comment}{// Register input message port}
00051         d_port_id_in = pmt::mp(\textcolor{stringliteral}{"Msg in"});
00052         message\_port\_register\_in(d_port_id_in);
00053         set\_msg\_handler(d_port_id_in, boost::bind(&
      msg_manipulator_impl::handle_msg, \textcolor{keyword}{this}, \_1));
00054         
00055         \textcolor{comment}{// Register output message port}
00056         d_port_id_out = pmt::mp(\textcolor{stringliteral}{"Msg out"});
00057         message\_port\_register\_out(d_port_id_out);
00058     \}
00059     
00060     \textcolor{keywordtype}{void}
00061     msg_manipulator_impl::set_const_add(std::vector<float> val)\{
00062         d_const_add = val;
00063     \}
00064     
00065     \textcolor{keywordtype}{void}
00066     msg_manipulator_impl::set_const_mult(std::vector<float> val)\{
00067         d_const_mult = val;
00068     \}
00069     
00070     \textcolor{keywordtype}{void}
00071     msg_manipulator_impl::handle_msg(pmt::pmt\_t msg)\{
00072         \textcolor{comment}{// Go through msg parts and check symbols}
00073         pmt::pmt\_t msg\_part\_symbol, msg\_part\_value;
00074         \textcolor{keywordtype}{bool} symbol\_found;
00075         std::vector<float> value\_new;
00076         std::vector<pmt::pmt\_t> store\_msg;
00077         \textcolor{keywordtype}{int} index;
00078         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<pmt::length(msg); k++)\{
00079             symbol\_found = \textcolor{keyword}{false};
00080             msg\_part\_symbol = pmt::nth(0,pmt::nth(k,msg));
00081             msg\_part\_value = pmt::nth(1,pmt::nth(k,msg));
00082             \textcolor{comment}{// Go through given symbols}
00083             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} p=0; p<d_symbols.size(); p++)\{
00084                 \textcolor{keywordflow}{if}(pmt::symbol\_to\_string(msg\_part\_symbol)==d_symbols[p])\{
00085                     index = p;
00086                     symbol\_found = \textcolor{keyword}{true};
00087                 \}
00088             \}
00089             \textcolor{comment}{// Store msg part}
00090             \textcolor{keywordflow}{if}(symbol\_found && pmt::is\_f32vector(msg\_part\_value))\{ \textcolor{comment}{// use const\_add and const\_mult if
       symbol found and value is f32 vector, then store new msg}
00091                 value\_new = pmt::f32vector\_elements(msg\_part\_value);
00092                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} m=0; m<value\_new.size(); m++)\{ \textcolor{comment}{// manipulate vector}
00093                     value\_new[m] = (value\_new[m]+d_const_add[index])*
      d_const_mult[index];
00094                 \}
00095                 store\_msg.push\_back(pmt::list2(msg\_part\_symbol,pmt::init\_f32vector(value\_new.size(), 
      value\_new)));
00096             \}
00097             \textcolor{keywordflow}{else}\{ \textcolor{comment}{// just store msg if not found}
00098                 store\_msg.push\_back(pmt::nth(k,msg));
00099             \}
00100         \}
00101         
00102         \textcolor{comment}{// Repack msg}
00103         pmt::pmt\_t msg\_out;
00104         \textcolor{keywordflow}{if}(store\_msg.size()==0) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"Store msg vector has unvalid length (size=0)"});
00105         msg\_out = pmt::list1(store\_msg[0]); \textcolor{comment}{// init pmt list}
00106         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=1; k<store\_msg.size(); k++)\{ \textcolor{comment}{// add pmt list}
00107             msg\_out = pmt::list\_add(msg\_out, store\_msg[k]);
00108         \}
00109         
00110         \textcolor{comment}{// Publish msg}
00111         message\_port\_pub(d_port_id_out,msg\_out);
00112     \}
00113 
00114     \textcolor{comment}{/*}
00115 \textcolor{comment}{     * Our virtual destructor.}
00116 \textcolor{comment}{     */}
00117     msg_manipulator_impl::~msg_manipulator_impl()
00118     \{
00119     \}
00120 
00121   \} \textcolor{comment}{/* namespace radar */}
00122 \} \textcolor{comment}{/* namespace gr */}
00123 
\end{DoxyCode}
